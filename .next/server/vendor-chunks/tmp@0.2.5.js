/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tmp@0.2.5";
exports.ids = ["vendor-chunks/tmp@0.2.5"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/tmp@0.2.5/node_modules/tmp/lib/tmp.js":
/*!******************************************************************!*\
  !*** ./node_modules/.pnpm/tmp@0.2.5/node_modules/tmp/lib/tmp.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst _c = { fs: fs.constants, os: os.constants };\n\n/*\n * The working inner variables.\n */\nconst // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  TEMPLATE_PATTERN = /XXXXXX/,\n  DEFAULT_TRIES = 3,\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n  // constants are off on the windows platform and will not match the actual errno codes\n  IS_WIN32 = os.platform() === 'win32',\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n  DIR_MODE = 0o700 /* 448 */,\n  FILE_MODE = 0o600 /* 384 */,\n  EXIT = 'exit',\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\n  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);\n\nlet _gracefulCleanup = false;\n\n/**\n * Recursively remove a directory and its contents.\n *\n * @param {string} dirPath path of directory to remove\n * @param {Function} callback\n * @private\n */\nfunction rimraf(dirPath, callback) {\n  return fs.rm(dirPath, { recursive: true }, callback);\n}\n\n/**\n * Recursively remove a directory and its contents, synchronously.\n *\n * @param {string} dirPath path of directory to remove\n * @private\n */\nfunction FN_RIMRAF_SYNC(dirPath) {\n  return fs.rmSync(dirPath, { recursive: true });\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  _assertAndSanitizeOptions(opts, function (err, sanitizedOptions) {\n    if (err) return cb(err);\n\n    let tries = sanitizedOptions.tries;\n    (function _getUniqueName() {\n      try {\n        const name = _generateTmpName(sanitizedOptions);\n\n        // check whether the path exists then retry if needed\n        fs.stat(name, function (err) {\n          /* istanbul ignore else */\n          if (!err) {\n            /* istanbul ignore else */\n            if (tries-- > 0) return _getUniqueName();\n\n            return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n          }\n\n          cb(null, name);\n        });\n      } catch (err) {\n        cb(err);\n      }\n    })();\n  });\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n\n  const sanitizedOptions = _assertAndSanitizeOptionsSync(opts);\n\n  let tries = sanitizedOptions.tries;\n  do {\n    const name = _generateTmpName(sanitizedOptions);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbu ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(possibleErr) {\n          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n        });\n      } else {\n        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n        // about the descriptor\n        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n      }\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  let fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  const args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  const args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !_isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  };\n\n  if (0 <= fdPath[0])\n    fs.close(fdPath[0], function () {\n      fs.unlink(fdPath[1], _handler);\n    });\n  else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  let rethrownException = null;\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    } catch (e) {\n      // reraise any unanticipated error\n      if (!_isENOENT(e)) rethrownException = e;\n    }\n  }\n  if (rethrownException !== null) {\n    throw rethrownException;\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts, sync) {\n  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n  let called = false;\n\n  // if sync is true, the next parameter will be ignored\n  return function _cleanupCallback(next) {\n    /* istanbul ignore else */\n    if (!called) {\n      // remove cleanupCallback from cache\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n\n      called = true;\n      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n        return removeFunction(fileOrDirName);\n      } else {\n        return removeFunction(fileOrDirName, next || function () {});\n      }\n    }\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  let value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (let i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  // copy options so we do not leak the changes we make internally\n  const actualOptions = {};\n  for (const key of Object.getOwnPropertyNames(options)) {\n    actualOptions[key] = options[key];\n  }\n\n  return [actualOptions, callback];\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @private\n */\nfunction _resolvePath(name, tmpDir, cb) {\n  const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);\n\n  fs.stat(pathToResolve, function (err) {\n    if (err) {\n      fs.realpath(path.dirname(pathToResolve), function (err, parentDir) {\n        if (err) return cb(err);\n\n        cb(null, path.join(parentDir, path.basename(pathToResolve)));\n      });\n    } else {\n      fs.realpath(pathToResolve, cb);\n    }\n  });\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @private\n */\nfunction _resolvePathSync(name, tmpDir) {\n  const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);\n\n  try {\n    fs.statSync(pathToResolve);\n    return fs.realpathSync(pathToResolve);\n  } catch (_err) {\n    const parentDir = fs.realpathSync(path.dirname(pathToResolve));\n\n    return path.join(parentDir, path.basename(pathToResolve));\n  }\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n  const tmpDir = opts.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.name)) {\n    return path.join(tmpDir, opts.dir, opts.name);\n  }\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.template)) {\n    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n  }\n\n  // prefix and postfix\n  const name = [\n    opts.prefix ? opts.prefix : 'tmp',\n    '-',\n    process.pid,\n    '-',\n    _randomChars(12),\n    opts.postfix ? '-' + opts.postfix : ''\n  ].join('');\n\n  return path.join(tmpDir, opts.dir, name);\n}\n\n/**\n * Asserts and sanitizes the basic options.\n *\n * @private\n */\nfunction _assertOptionsBase(options) {\n  if (!_isUndefined(options.name)) {\n    const name = options.name;\n\n    // assert that name is not absolute and does not contain a path\n    if (path.isAbsolute(name)) throw new Error(`name option must not contain an absolute path, found \"${name}\".`);\n\n    // must not fail on valid .<name> or ..<name> or similar such constructs\n    const basename = path.basename(name);\n    if (basename === '..' || basename === '.' || basename !== name)\n      throw new Error(`name option must not contain a path, found \"${name}\".`);\n  }\n\n  /* istanbul ignore else */\n  if (!_isUndefined(options.template) && !options.template.match(TEMPLATE_PATTERN)) {\n    throw new Error(`Invalid template, found \"${options.template}\".`);\n  }\n\n  /* istanbul ignore else */\n  if ((!_isUndefined(options.tries) && isNaN(options.tries)) || options.tries < 0) {\n    throw new Error(`Invalid tries, found \"${options.tries}\".`);\n  }\n\n  // if a name was specified we will try once\n  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n  options.keep = !!options.keep;\n  options.detachDescriptor = !!options.detachDescriptor;\n  options.discardDescriptor = !!options.discardDescriptor;\n  options.unsafeCleanup = !!options.unsafeCleanup;\n\n  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;\n  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;\n}\n\n/**\n * Gets the relative directory to tmpDir.\n *\n * @private\n */\nfunction _getRelativePath(option, name, tmpDir, cb) {\n  if (_isUndefined(name)) return cb(null);\n\n  _resolvePath(name, tmpDir, function (err, resolvedPath) {\n    if (err) return cb(err);\n\n    const relativePath = path.relative(tmpDir, resolvedPath);\n\n    if (!resolvedPath.startsWith(tmpDir)) {\n      return cb(new Error(`${option} option must be relative to \"${tmpDir}\", found \"${relativePath}\".`));\n    }\n\n    cb(null, relativePath);\n  });\n}\n\n/**\n * Gets the relative path to tmpDir.\n *\n * @private\n */\nfunction _getRelativePathSync(option, name, tmpDir) {\n  if (_isUndefined(name)) return;\n\n  const resolvedPath = _resolvePathSync(name, tmpDir);\n  const relativePath = path.relative(tmpDir, resolvedPath);\n\n  if (!resolvedPath.startsWith(tmpDir)) {\n    throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${relativePath}\".`);\n  }\n\n  return relativePath;\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @private\n */\nfunction _assertAndSanitizeOptions(options, cb) {\n  _getTmpDir(options, function (err, tmpDir) {\n    if (err) return cb(err);\n\n    options.tmpdir = tmpDir;\n\n    try {\n      _assertOptionsBase(options, tmpDir);\n    } catch (err) {\n      return cb(err);\n    }\n\n    // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n    _getRelativePath('dir', options.dir, tmpDir, function (err, dir) {\n      if (err) return cb(err);\n\n      options.dir = _isUndefined(dir) ? '' : dir;\n\n      // sanitize further if template is relative to options.dir\n      _getRelativePath('template', options.template, tmpDir, function (err, template) {\n        if (err) return cb(err);\n\n        options.template = template;\n\n        cb(null, options);\n      });\n    });\n  });\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @private\n */\nfunction _assertAndSanitizeOptionsSync(options) {\n  const tmpDir = (options.tmpdir = _getTmpDirSync(options));\n\n  _assertOptionsBase(options, tmpDir);\n\n  const dir = _getRelativePathSync('dir', options.dir, tmpDir);\n  options.dir = _isUndefined(dir) ? '' : dir;\n\n  options.template = _getRelativePathSync('template', options.template, tmpDir);\n\n  return options;\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isEBADF(error) {\n  return _isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isENOENT(error) {\n  return _isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */\nfunction _isExpectedError(error, errno, code) {\n  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n */\nfunction _getTmpDir(options, cb) {\n  return fs.realpath((options && options.tmpdir) || os.tmpdir(), cb);\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n */\nfunction _getTmpDirSync(options) {\n  return fs.realpathSync((options && options.tmpdir) || os.tmpdir());\n}\n\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, \"tmpdir\", ({\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDirSync();\n  }\n}));\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vdG1wQDAuMi41L25vZGVfbW9kdWxlcy90bXAvbGliL3RtcC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNB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YyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QixjQUFjLFVBQVU7QUFDeEI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLGNBQWM7QUFDNUI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsY0FBYztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7O0FBRUYsa0JBQWtCO0FBQ2xCLHNCQUFzQjs7QUFFdEIsbUJBQW1CO0FBQ25CLHVCQUF1Qjs7QUFFdkIsc0JBQXNCO0FBQ3RCLDBCQUEwQjs7QUFFMUIsaUNBQWlDIiwic291cmNlcyI6WyIvVXNlcnMvaWxlZTAwL0Rlc2t0b3AvSFJDLUFwcGxpY2F0aW9uL25vZGVfbW9kdWxlcy8ucG5wbS90bXBAMC4yLjUvbm9kZV9tb2R1bGVzL3RtcC9saWIvdG1wLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVG1wXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTcgS0FSQVNaSSBJc3R2YW4gPGdpdGh1YkBzcGFtLnJhc3ppLmh1PlxuICpcbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBfYyA9IHsgZnM6IGZzLmNvbnN0YW50cywgb3M6IG9zLmNvbnN0YW50cyB9O1xuXG4vKlxuICogVGhlIHdvcmtpbmcgaW5uZXIgdmFyaWFibGVzLlxuICovXG5jb25zdCAvLyB0aGUgcmFuZG9tIGNoYXJhY3RlcnMgdG8gY2hvb3NlIGZyb21cbiAgUkFORE9NX0NIQVJTID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcbiAgVEVNUExBVEVfUEFUVEVSTiA9IC9YWFhYWFgvLFxuICBERUZBVUxUX1RSSUVTID0gMyxcbiAgQ1JFQVRFX0ZMQUdTID0gKF9jLk9fQ1JFQVQgfHwgX2MuZnMuT19DUkVBVCkgfCAoX2MuT19FWENMIHx8IF9jLmZzLk9fRVhDTCkgfCAoX2MuT19SRFdSIHx8IF9jLmZzLk9fUkRXUiksXG4gIC8vIGNvbnN0YW50cyBhcmUgb2ZmIG9uIHRoZSB3aW5kb3dzIHBsYXRmb3JtIGFuZCB3aWxsIG5vdCBtYXRjaCB0aGUgYWN0dWFsIGVycm5vIGNvZGVzXG4gIElTX1dJTjMyID0gb3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJyxcbiAgRUJBREYgPSBfYy5FQkFERiB8fCBfYy5vcy5lcnJuby5FQkFERixcbiAgRU5PRU5UID0gX2MuRU5PRU5UIHx8IF9jLm9zLmVycm5vLkVOT0VOVCxcbiAgRElSX01PREUgPSAwbzcwMCAvKiA0NDggKi8sXG4gIEZJTEVfTU9ERSA9IDBvNjAwIC8qIDM4NCAqLyxcbiAgRVhJVCA9ICdleGl0JyxcbiAgLy8gdGhpcyB3aWxsIGhvbGQgdGhlIG9iamVjdHMgbmVlZCB0byBiZSByZW1vdmVkIG9uIGV4aXRcbiAgX3JlbW92ZU9iamVjdHMgPSBbXSxcbiAgLy8gQVBJIGNoYW5nZSBpbiBmcy5ybWRpclN5bmMgbGVhZHMgdG8gZXJyb3Igd2hlbiBwYXNzaW5nIGluIGEgc2Vjb25kIHBhcmFtZXRlciwgZS5nLiB0aGUgY2FsbGJhY2tcbiAgRk5fUk1ESVJfU1lOQyA9IGZzLnJtZGlyU3luYy5iaW5kKGZzKTtcblxubGV0IF9ncmFjZWZ1bENsZWFudXAgPSBmYWxzZTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSByZW1vdmUgYSBkaXJlY3RvcnkgYW5kIGl0cyBjb250ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyUGF0aCBwYXRoIG9mIGRpcmVjdG9yeSB0byByZW1vdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByaW1yYWYoZGlyUGF0aCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZzLnJtKGRpclBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSByZW1vdmUgYSBkaXJlY3RvcnkgYW5kIGl0cyBjb250ZW50cywgc3luY2hyb25vdXNseS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyUGF0aCBwYXRoIG9mIGRpcmVjdG9yeSB0byByZW1vdmVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEZOX1JJTVJBRl9TWU5DKGRpclBhdGgpIHtcbiAgcmV0dXJuIGZzLnJtU3luYyhkaXJQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbn1cblxuLyoqXG4gKiBHZXRzIGEgdGVtcG9yYXJ5IGZpbGUgbmFtZS5cbiAqXG4gKiBAcGFyYW0geyhPcHRpb25zfHRtcE5hbWVDYWxsYmFjayl9IG9wdGlvbnMgb3B0aW9ucyBvciBjYWxsYmFja1xuICogQHBhcmFtIHs/dG1wTmFtZUNhbGxiYWNrfSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdG1wTmFtZShvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGNhbGxiYWNrKSxcbiAgICBvcHRzID0gYXJnc1swXSxcbiAgICBjYiA9IGFyZ3NbMV07XG5cbiAgX2Fzc2VydEFuZFNhbml0aXplT3B0aW9ucyhvcHRzLCBmdW5jdGlvbiAoZXJyLCBzYW5pdGl6ZWRPcHRpb25zKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICBsZXQgdHJpZXMgPSBzYW5pdGl6ZWRPcHRpb25zLnRyaWVzO1xuICAgIChmdW5jdGlvbiBfZ2V0VW5pcXVlTmFtZSgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBfZ2VuZXJhdGVUbXBOYW1lKHNhbml0aXplZE9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHBhdGggZXhpc3RzIHRoZW4gcmV0cnkgaWYgbmVlZGVkXG4gICAgICAgIGZzLnN0YXQobmFtZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodHJpZXMtLSA+IDApIHJldHVybiBfZ2V0VW5pcXVlTmFtZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IGEgdW5pcXVlIHRtcCBmaWxlbmFtZSwgbWF4IHRyaWVzIHJlYWNoZWQgJyArIG5hbWUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYihudWxsLCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91cyB2ZXJzaW9uIG9mIHRtcE5hbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBnZW5lcmF0ZWQgcmFuZG9tIG5hbWVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgb3B0aW9ucyBhcmUgaW52YWxpZCBvciBjb3VsZCBub3QgZ2VuZXJhdGUgYSBmaWxlbmFtZVxuICovXG5mdW5jdGlvbiB0bXBOYW1lU3luYyhvcHRpb25zKSB7XG4gIGNvbnN0IGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucyksXG4gICAgb3B0cyA9IGFyZ3NbMF07XG5cbiAgY29uc3Qgc2FuaXRpemVkT3B0aW9ucyA9IF9hc3NlcnRBbmRTYW5pdGl6ZU9wdGlvbnNTeW5jKG9wdHMpO1xuXG4gIGxldCB0cmllcyA9IHNhbml0aXplZE9wdGlvbnMudHJpZXM7XG4gIGRvIHtcbiAgICBjb25zdCBuYW1lID0gX2dlbmVyYXRlVG1wTmFtZShzYW5pdGl6ZWRPcHRpb25zKTtcbiAgICB0cnkge1xuICAgICAgZnMuc3RhdFN5bmMobmFtZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICB9IHdoaWxlICh0cmllcy0tID4gMCk7XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IGEgdW5pcXVlIHRtcCBmaWxlbmFtZSwgbWF4IHRyaWVzIHJlYWNoZWQnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCBvcGVucyBhIHRlbXBvcmFyeSBmaWxlLlxuICpcbiAqIEBwYXJhbSB7KE9wdGlvbnN8bnVsbHx1bmRlZmluZWR8ZmlsZUNhbGxiYWNrKX0gb3B0aW9ucyB0aGUgY29uZmlnIG9wdGlvbnMgb3IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIG51bGwgb3IgdW5kZWZpbmVkXG4gKiBAcGFyYW0gez9maWxlQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGZpbGUob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjayksXG4gICAgb3B0cyA9IGFyZ3NbMF0sXG4gICAgY2IgPSBhcmdzWzFdO1xuXG4gIC8vIGdldHMgYSB0ZW1wb3JhcnkgZmlsZW5hbWVcbiAgdG1wTmFtZShvcHRzLCBmdW5jdGlvbiBfdG1wTmFtZUNyZWF0ZWQoZXJyLCBuYW1lKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIC8vIGNyZWF0ZSBhbmQgb3BlbiB0aGUgZmlsZVxuICAgIGZzLm9wZW4obmFtZSwgQ1JFQVRFX0ZMQUdTLCBvcHRzLm1vZGUgfHwgRklMRV9NT0RFLCBmdW5jdGlvbiBfZmlsZUNyZWF0ZWQoZXJyLCBmZCkge1xuICAgICAgLyogaXN0YW5idSBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChvcHRzLmRpc2NhcmREZXNjcmlwdG9yKSB7XG4gICAgICAgIHJldHVybiBmcy5jbG9zZShmZCwgZnVuY3Rpb24gX2Rpc2NhcmRDYWxsYmFjayhwb3NzaWJsZUVycikge1xuICAgICAgICAgIC8vIHRoZSBjaGFuY2Ugb2YgZ2V0dGluZyBhbiBlcnJvciBvbiBjbG9zZSBoZXJlIGlzIHJhdGhlciBsb3cgYW5kIG1pZ2h0IG9jY3VyIGluIHRoZSBtb3N0IGVkZ2llc3QgY2FzZXMgb25seVxuICAgICAgICAgIHJldHVybiBjYihwb3NzaWJsZUVyciwgbmFtZSwgdW5kZWZpbmVkLCBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCAtMSwgb3B0cywgZmFsc2UpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZXRhY2hEZXNjcmlwdG9yIHBhc3NlcyB0aGUgZGVzY3JpcHRvciB3aGVyZWFzIGRpc2NhcmREZXNjcmlwdG9yIGNsb3NlcyBpdCwgZWl0aGVyIHdheSwgd2Ugbm8gbG9uZ2VyIGNhcmVcbiAgICAgICAgLy8gYWJvdXQgdGhlIGRlc2NyaXB0b3JcbiAgICAgICAgY29uc3QgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA9IG9wdHMuZGlzY2FyZERlc2NyaXB0b3IgfHwgb3B0cy5kZXRhY2hEZXNjcmlwdG9yO1xuICAgICAgICBjYihudWxsLCBuYW1lLCBmZCwgX3ByZXBhcmVUbXBGaWxlUmVtb3ZlQ2FsbGJhY2sobmFtZSwgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA/IC0xIDogZmQsIG9wdHMsIGZhbHNlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtGaWxlU3luY09iamVjdH0gb2JqZWN0IGNvbnNpc3RzIG9mIG5hbWUsIGZkIGFuZCByZW1vdmVDYWxsYmFja1xuICogQHRocm93cyB7RXJyb3J9IGlmIGNhbm5vdCBjcmVhdGUgYSBmaWxlXG4gKi9cbmZ1bmN0aW9uIGZpbGVTeW5jKG9wdGlvbnMpIHtcbiAgY29uc3QgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zKSxcbiAgICBvcHRzID0gYXJnc1swXTtcblxuICBjb25zdCBkaXNjYXJkT3JEZXRhY2hEZXNjcmlwdG9yID0gb3B0cy5kaXNjYXJkRGVzY3JpcHRvciB8fCBvcHRzLmRldGFjaERlc2NyaXB0b3I7XG4gIGNvbnN0IG5hbWUgPSB0bXBOYW1lU3luYyhvcHRzKTtcbiAgbGV0IGZkID0gZnMub3BlblN5bmMobmFtZSwgQ1JFQVRFX0ZMQUdTLCBvcHRzLm1vZGUgfHwgRklMRV9NT0RFKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKG9wdHMuZGlzY2FyZERlc2NyaXB0b3IpIHtcbiAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgIGZkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGZkOiBmZCxcbiAgICByZW1vdmVDYWxsYmFjazogX3ByZXBhcmVUbXBGaWxlUmVtb3ZlQ2FsbGJhY2sobmFtZSwgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA/IC0xIDogZmQsIG9wdHMsIHRydWUpXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRlbXBvcmFyeSBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xkaXJDYWxsYmFjayl9IG9wdGlvbnMgdGhlIG9wdGlvbnMgb3IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0gez9kaXJDYWxsYmFja30gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZGlyKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucywgY2FsbGJhY2spLFxuICAgIG9wdHMgPSBhcmdzWzBdLFxuICAgIGNiID0gYXJnc1sxXTtcblxuICAvLyBnZXRzIGEgdGVtcG9yYXJ5IGZpbGVuYW1lXG4gIHRtcE5hbWUob3B0cywgZnVuY3Rpb24gX3RtcE5hbWVDcmVhdGVkKGVyciwgbmFtZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGRpcmVjdG9yeVxuICAgIGZzLm1rZGlyKG5hbWUsIG9wdHMubW9kZSB8fCBESVJfTU9ERSwgZnVuY3Rpb24gX2RpckNyZWF0ZWQoZXJyKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGNiKG51bGwsIG5hbWUsIF9wcmVwYXJlVG1wRGlyUmVtb3ZlQ2FsbGJhY2sobmFtZSwgb3B0cywgZmFsc2UpKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXMgdmVyc2lvbiBvZiBkaXIuXG4gKlxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RGlyU3luY09iamVjdH0gb2JqZWN0IGNvbnNpc3RzIG9mIG5hbWUgYW5kIHJlbW92ZUNhbGxiYWNrXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgY2Fubm90IGNyZWF0ZSBhIGRpcmVjdG9yeVxuICovXG5mdW5jdGlvbiBkaXJTeW5jKG9wdGlvbnMpIHtcbiAgY29uc3QgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zKSxcbiAgICBvcHRzID0gYXJnc1swXTtcblxuICBjb25zdCBuYW1lID0gdG1wTmFtZVN5bmMob3B0cyk7XG4gIGZzLm1rZGlyU3luYyhuYW1lLCBvcHRzLm1vZGUgfHwgRElSX01PREUpO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICByZW1vdmVDYWxsYmFjazogX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayhuYW1lLCBvcHRzLCB0cnVlKVxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZmlsZXMgYXN5bmNocm9ub3VzbHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZkUGF0aFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JlbW92ZUZpbGVBc3luYyhmZFBhdGgsIG5leHQpIHtcbiAgY29uc3QgX2hhbmRsZXIgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiAhX2lzRU5PRU5UKGVycikpIHtcbiAgICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgfVxuICAgIG5leHQoKTtcbiAgfTtcblxuICBpZiAoMCA8PSBmZFBhdGhbMF0pXG4gICAgZnMuY2xvc2UoZmRQYXRoWzBdLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmcy51bmxpbmsoZmRQYXRoWzFdLCBfaGFuZGxlcik7XG4gICAgfSk7XG4gIGVsc2UgZnMudW5saW5rKGZkUGF0aFsxXSwgX2hhbmRsZXIpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZmlsZXMgc3luY2hyb25vdXNseS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmRQYXRoXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVtb3ZlRmlsZVN5bmMoZmRQYXRoKSB7XG4gIGxldCByZXRocm93bkV4Y2VwdGlvbiA9IG51bGw7XG4gIHRyeSB7XG4gICAgaWYgKDAgPD0gZmRQYXRoWzBdKSBmcy5jbG9zZVN5bmMoZmRQYXRoWzBdKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICBpZiAoIV9pc0VCQURGKGUpICYmICFfaXNFTk9FTlQoZSkpIHRocm93IGU7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnVubGlua1N5bmMoZmRQYXRoWzFdKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyByZXJhaXNlIGFueSB1bmFudGljaXBhdGVkIGVycm9yXG4gICAgICBpZiAoIV9pc0VOT0VOVChlKSkgcmV0aHJvd25FeGNlcHRpb24gPSBlO1xuICAgIH1cbiAgfVxuICBpZiAocmV0aHJvd25FeGNlcHRpb24gIT09IG51bGwpIHtcbiAgICB0aHJvdyByZXRocm93bkV4Y2VwdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIFByZXBhcmVzIHRoZSBjYWxsYmFjayBmb3IgcmVtb3ZhbCBvZiB0aGUgdGVtcG9yYXJ5IGZpbGUuXG4gKlxuICogUmV0dXJucyBlaXRoZXIgYSBzeW5jIGNhbGxiYWNrIG9yIGEgYXN5bmMgY2FsbGJhY2sgZGVwZW5kaW5nIG9uIHdoZXRoZXJcbiAqIGZpbGVTeW5jIG9yIGZpbGUgd2FzIGNhbGxlZCwgd2hpY2ggaXMgZXhwcmVzc2VkIGJ5IHRoZSBzeW5jIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcGF0aCBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtudW1iZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3luY1xuICogQHJldHVybnMge2ZpbGVDYWxsYmFjayB8IGZpbGVDYWxsYmFja1N5bmN9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCBmZCwgb3B0cywgc3luYykge1xuICBjb25zdCByZW1vdmVDYWxsYmFja1N5bmMgPSBfcHJlcGFyZVJlbW92ZUNhbGxiYWNrKF9yZW1vdmVGaWxlU3luYywgW2ZkLCBuYW1lXSwgc3luYyk7XG4gIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhfcmVtb3ZlRmlsZUFzeW5jLCBbZmQsIG5hbWVdLCBzeW5jLCByZW1vdmVDYWxsYmFja1N5bmMpO1xuXG4gIGlmICghb3B0cy5rZWVwKSBfcmVtb3ZlT2JqZWN0cy51bnNoaWZ0KHJlbW92ZUNhbGxiYWNrU3luYyk7XG5cbiAgcmV0dXJuIHN5bmMgPyByZW1vdmVDYWxsYmFja1N5bmMgOiByZW1vdmVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBQcmVwYXJlcyB0aGUgY2FsbGJhY2sgZm9yIHJlbW92YWwgb2YgdGhlIHRlbXBvcmFyeSBkaXJlY3RvcnkuXG4gKlxuICogUmV0dXJucyBlaXRoZXIgYSBzeW5jIGNhbGxiYWNrIG9yIGEgYXN5bmMgY2FsbGJhY2sgZGVwZW5kaW5nIG9uIHdoZXRoZXJcbiAqIHRtcEZpbGVTeW5jIG9yIHRtcEZpbGUgd2FzIGNhbGxlZCwgd2hpY2ggaXMgZXhwcmVzc2VkIGJ5IHRoZSBzeW5jIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3luY1xuICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlVG1wRGlyUmVtb3ZlQ2FsbGJhY2sobmFtZSwgb3B0cywgc3luYykge1xuICBjb25zdCByZW1vdmVGdW5jdGlvbiA9IG9wdHMudW5zYWZlQ2xlYW51cCA/IHJpbXJhZiA6IGZzLnJtZGlyLmJpbmQoZnMpO1xuICBjb25zdCByZW1vdmVGdW5jdGlvblN5bmMgPSBvcHRzLnVuc2FmZUNsZWFudXAgPyBGTl9SSU1SQUZfU1lOQyA6IEZOX1JNRElSX1NZTkM7XG4gIGNvbnN0IHJlbW92ZUNhbGxiYWNrU3luYyA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2socmVtb3ZlRnVuY3Rpb25TeW5jLCBuYW1lLCBzeW5jKTtcbiAgY29uc3QgcmVtb3ZlQ2FsbGJhY2sgPSBfcHJlcGFyZVJlbW92ZUNhbGxiYWNrKHJlbW92ZUZ1bmN0aW9uLCBuYW1lLCBzeW5jLCByZW1vdmVDYWxsYmFja1N5bmMpO1xuICBpZiAoIW9wdHMua2VlcCkgX3JlbW92ZU9iamVjdHMudW5zaGlmdChyZW1vdmVDYWxsYmFja1N5bmMpO1xuXG4gIHJldHVybiBzeW5jID8gcmVtb3ZlQ2FsbGJhY2tTeW5jIDogcmVtb3ZlQ2FsbGJhY2s7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGd1YXJkZWQgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHJlbW92ZUZ1bmN0aW9uIGNhbGwuXG4gKlxuICogVGhlIGNsZWFudXAgY2FsbGJhY2sgaXMgc2F2ZSB0byBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gKiBTdWJzZXF1ZW50IGludm9jYXRpb25zIHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZW1vdmVGdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVPckRpck5hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3luY1xuICogQHBhcmFtIHtjbGVhbnVwQ2FsbGJhY2tTeW5jP30gY2xlYW51cENhbGxiYWNrU3luY1xuICogQHJldHVybnMge2NsZWFudXBDYWxsYmFjayB8IGNsZWFudXBDYWxsYmFja1N5bmN9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcHJlcGFyZVJlbW92ZUNhbGxiYWNrKHJlbW92ZUZ1bmN0aW9uLCBmaWxlT3JEaXJOYW1lLCBzeW5jLCBjbGVhbnVwQ2FsbGJhY2tTeW5jKSB7XG4gIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAvLyBpZiBzeW5jIGlzIHRydWUsIHRoZSBuZXh0IHBhcmFtZXRlciB3aWxsIGJlIGlnbm9yZWRcbiAgcmV0dXJuIGZ1bmN0aW9uIF9jbGVhbnVwQ2FsbGJhY2sobmV4dCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIC8vIHJlbW92ZSBjbGVhbnVwQ2FsbGJhY2sgZnJvbSBjYWNoZVxuICAgICAgY29uc3QgdG9SZW1vdmUgPSBjbGVhbnVwQ2FsbGJhY2tTeW5jIHx8IF9jbGVhbnVwQ2FsbGJhY2s7XG4gICAgICBjb25zdCBpbmRleCA9IF9yZW1vdmVPYmplY3RzLmluZGV4T2YodG9SZW1vdmUpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChpbmRleCA+PSAwKSBfcmVtb3ZlT2JqZWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgaWYgKHN5bmMgfHwgcmVtb3ZlRnVuY3Rpb24gPT09IEZOX1JNRElSX1NZTkMgfHwgcmVtb3ZlRnVuY3Rpb24gPT09IEZOX1JJTVJBRl9TWU5DKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVGdW5jdGlvbihmaWxlT3JEaXJOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZW1vdmVGdW5jdGlvbihmaWxlT3JEaXJOYW1lLCBuZXh0IHx8IGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGdhcmJhZ2UgY29sbGVjdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nYXJiYWdlQ29sbGVjdG9yKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9ncmFjZWZ1bENsZWFudXApIHJldHVybjtcblxuICAvLyB0aGUgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIHJlbW92ZXMgaXRzZWxmIGZyb20gX3JlbW92ZU9iamVjdHMsXG4gIC8vIGxvb3AgdW50aWwgX3JlbW92ZU9iamVjdHMgaXMgZW1wdHlcbiAgd2hpbGUgKF9yZW1vdmVPYmplY3RzLmxlbmd0aCkge1xuICAgIHRyeSB7XG4gICAgICBfcmVtb3ZlT2JqZWN0c1swXSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGFscmVhZHkgcmVtb3ZlZD9cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSYW5kb20gbmFtZSBnZW5lcmF0b3IgYmFzZWQgb24gY3J5cHRvLlxuICogQWRhcHRlZCBmcm9tIGh0dHA6Ly9ibG9nLnRvbXBhd2xhay5vcmcvaG93LXRvLWdlbmVyYXRlLXJhbmRvbS12YWx1ZXMtbm9kZWpzLWphdmFzY3JpcHRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaG93TWFueVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGdlbmVyYXRlZCByYW5kb20gbmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JhbmRvbUNoYXJzKGhvd01hbnkpIHtcbiAgbGV0IHZhbHVlID0gW10sXG4gICAgcm5kID0gbnVsbDtcblxuICAvLyBtYWtlIHN1cmUgdGhhdCB3ZSBkbyBub3QgZmFpbCBiZWNhdXNlIHdlIHJhbiBvdXQgb2YgZW50cm9weVxuICB0cnkge1xuICAgIHJuZCA9IGNyeXB0by5yYW5kb21CeXRlcyhob3dNYW55KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJuZCA9IGNyeXB0by5wc2V1ZG9SYW5kb21CeXRlcyhob3dNYW55KTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG93TWFueTsgaSsrKSB7XG4gICAgdmFsdWUucHVzaChSQU5ET01fQ0hBUlNbcm5kW2ldICUgUkFORE9NX0NIQVJTLmxlbmd0aF0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlLmpvaW4oJycpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBgb2JqYCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBpcyB1bmRlZmluZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc1VuZGVmaW5lZChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgZnVuY3Rpb24gYXJndW1lbnRzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGVscHMgdG8gaGF2ZSBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xudWxsfHVuZGVmaW5lZHxGdW5jdGlvbil9IG9wdGlvbnNcbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0FycmF5fSBwYXJzZWQgYXJndW1lbnRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcGFyc2VBcmd1bWVudHMob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIFt7fSwgb3B0aW9uc107XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoX2lzVW5kZWZpbmVkKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFt7fSwgY2FsbGJhY2tdO1xuICB9XG5cbiAgLy8gY29weSBvcHRpb25zIHNvIHdlIGRvIG5vdCBsZWFrIHRoZSBjaGFuZ2VzIHdlIG1ha2UgaW50ZXJuYWxseVxuICBjb25zdCBhY3R1YWxPcHRpb25zID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9wdGlvbnMpKSB7XG4gICAgYWN0dWFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICB9XG5cbiAgcmV0dXJuIFthY3R1YWxPcHRpb25zLCBjYWxsYmFja107XG59XG5cbi8qKlxuICogUmVzb2x2ZSB0aGUgc3BlY2lmaWVkIHBhdGggbmFtZSBpbiByZXNwZWN0IHRvIHRtcERpci5cbiAqXG4gKiBUaGUgc3BlY2lmaWVkIG5hbWUgbWlnaHQgaW5jbHVkZSByZWxhdGl2ZSBwYXRoIGNvbXBvbmVudHMsIGUuZy4gLi4vXG4gKiBzbyB3ZSBuZWVkIHRvIHJlc29sdmUgaW4gb3JkZXIgdG8gYmUgc3VyZSB0aGF0IGlzIGlzIGxvY2F0ZWQgaW5zaWRlIHRtcERpclxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZXNvbHZlUGF0aChuYW1lLCB0bXBEaXIsIGNiKSB7XG4gIGNvbnN0IHBhdGhUb1Jlc29sdmUgPSBwYXRoLmlzQWJzb2x1dGUobmFtZSkgPyBuYW1lIDogcGF0aC5qb2luKHRtcERpciwgbmFtZSk7XG5cbiAgZnMuc3RhdChwYXRoVG9SZXNvbHZlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgZnMucmVhbHBhdGgocGF0aC5kaXJuYW1lKHBhdGhUb1Jlc29sdmUpLCBmdW5jdGlvbiAoZXJyLCBwYXJlbnREaXIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgICAgY2IobnVsbCwgcGF0aC5qb2luKHBhcmVudERpciwgcGF0aC5iYXNlbmFtZShwYXRoVG9SZXNvbHZlKSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLnJlYWxwYXRoKHBhdGhUb1Jlc29sdmUsIGNiKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlc29sdmUgdGhlIHNwZWNpZmllZCBwYXRoIG5hbWUgaW4gcmVzcGVjdCB0byB0bXBEaXIuXG4gKlxuICogVGhlIHNwZWNpZmllZCBuYW1lIG1pZ2h0IGluY2x1ZGUgcmVsYXRpdmUgcGF0aCBjb21wb25lbnRzLCBlLmcuIC4uL1xuICogc28gd2UgbmVlZCB0byByZXNvbHZlIGluIG9yZGVyIHRvIGJlIHN1cmUgdGhhdCBpcyBpcyBsb2NhdGVkIGluc2lkZSB0bXBEaXJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVzb2x2ZVBhdGhTeW5jKG5hbWUsIHRtcERpcikge1xuICBjb25zdCBwYXRoVG9SZXNvbHZlID0gcGF0aC5pc0Fic29sdXRlKG5hbWUpID8gbmFtZSA6IHBhdGguam9pbih0bXBEaXIsIG5hbWUpO1xuXG4gIHRyeSB7XG4gICAgZnMuc3RhdFN5bmMocGF0aFRvUmVzb2x2ZSk7XG4gICAgcmV0dXJuIGZzLnJlYWxwYXRoU3luYyhwYXRoVG9SZXNvbHZlKTtcbiAgfSBjYXRjaCAoX2Vycikge1xuICAgIGNvbnN0IHBhcmVudERpciA9IGZzLnJlYWxwYXRoU3luYyhwYXRoLmRpcm5hbWUocGF0aFRvUmVzb2x2ZSkpO1xuXG4gICAgcmV0dXJuIHBhdGguam9pbihwYXJlbnREaXIsIHBhdGguYmFzZW5hbWUocGF0aFRvUmVzb2x2ZSkpO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbmV3IHRlbXBvcmFyeSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgbmV3IHJhbmRvbSBuYW1lIGFjY29yZGluZyB0byBvcHRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2VuZXJhdGVUbXBOYW1lKG9wdHMpIHtcbiAgY29uc3QgdG1wRGlyID0gb3B0cy50bXBkaXI7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFfaXNVbmRlZmluZWQob3B0cy5uYW1lKSkge1xuICAgIHJldHVybiBwYXRoLmpvaW4odG1wRGlyLCBvcHRzLmRpciwgb3B0cy5uYW1lKTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghX2lzVW5kZWZpbmVkKG9wdHMudGVtcGxhdGUpKSB7XG4gICAgcmV0dXJuIHBhdGguam9pbih0bXBEaXIsIG9wdHMuZGlyLCBvcHRzLnRlbXBsYXRlKS5yZXBsYWNlKFRFTVBMQVRFX1BBVFRFUk4sIF9yYW5kb21DaGFycyg2KSk7XG4gIH1cblxuICAvLyBwcmVmaXggYW5kIHBvc3RmaXhcbiAgY29uc3QgbmFtZSA9IFtcbiAgICBvcHRzLnByZWZpeCA/IG9wdHMucHJlZml4IDogJ3RtcCcsXG4gICAgJy0nLFxuICAgIHByb2Nlc3MucGlkLFxuICAgICctJyxcbiAgICBfcmFuZG9tQ2hhcnMoMTIpLFxuICAgIG9wdHMucG9zdGZpeCA/ICctJyArIG9wdHMucG9zdGZpeCA6ICcnXG4gIF0uam9pbignJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbih0bXBEaXIsIG9wdHMuZGlyLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIGFuZCBzYW5pdGl6ZXMgdGhlIGJhc2ljIG9wdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2Fzc2VydE9wdGlvbnNCYXNlKG9wdGlvbnMpIHtcbiAgaWYgKCFfaXNVbmRlZmluZWQob3B0aW9ucy5uYW1lKSkge1xuICAgIGNvbnN0IG5hbWUgPSBvcHRpb25zLm5hbWU7XG5cbiAgICAvLyBhc3NlcnQgdGhhdCBuYW1lIGlzIG5vdCBhYnNvbHV0ZSBhbmQgZG9lcyBub3QgY29udGFpbiBhIHBhdGhcbiAgICBpZiAocGF0aC5pc0Fic29sdXRlKG5hbWUpKSB0aHJvdyBuZXcgRXJyb3IoYG5hbWUgb3B0aW9uIG11c3Qgbm90IGNvbnRhaW4gYW4gYWJzb2x1dGUgcGF0aCwgZm91bmQgXCIke25hbWV9XCIuYCk7XG5cbiAgICAvLyBtdXN0IG5vdCBmYWlsIG9uIHZhbGlkIC48bmFtZT4gb3IgLi48bmFtZT4gb3Igc2ltaWxhciBzdWNoIGNvbnN0cnVjdHNcbiAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUobmFtZSk7XG4gICAgaWYgKGJhc2VuYW1lID09PSAnLi4nIHx8IGJhc2VuYW1lID09PSAnLicgfHwgYmFzZW5hbWUgIT09IG5hbWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5hbWUgb3B0aW9uIG11c3Qgbm90IGNvbnRhaW4gYSBwYXRoLCBmb3VuZCBcIiR7bmFtZX1cIi5gKTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICghX2lzVW5kZWZpbmVkKG9wdGlvbnMudGVtcGxhdGUpICYmICFvcHRpb25zLnRlbXBsYXRlLm1hdGNoKFRFTVBMQVRFX1BBVFRFUk4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRlbXBsYXRlLCBmb3VuZCBcIiR7b3B0aW9ucy50ZW1wbGF0ZX1cIi5gKTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoIV9pc1VuZGVmaW5lZChvcHRpb25zLnRyaWVzKSAmJiBpc05hTihvcHRpb25zLnRyaWVzKSkgfHwgb3B0aW9ucy50cmllcyA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHJpZXMsIGZvdW5kIFwiJHtvcHRpb25zLnRyaWVzfVwiLmApO1xuICB9XG5cbiAgLy8gaWYgYSBuYW1lIHdhcyBzcGVjaWZpZWQgd2Ugd2lsbCB0cnkgb25jZVxuICBvcHRpb25zLnRyaWVzID0gX2lzVW5kZWZpbmVkKG9wdGlvbnMubmFtZSkgPyBvcHRpb25zLnRyaWVzIHx8IERFRkFVTFRfVFJJRVMgOiAxO1xuICBvcHRpb25zLmtlZXAgPSAhIW9wdGlvbnMua2VlcDtcbiAgb3B0aW9ucy5kZXRhY2hEZXNjcmlwdG9yID0gISFvcHRpb25zLmRldGFjaERlc2NyaXB0b3I7XG4gIG9wdGlvbnMuZGlzY2FyZERlc2NyaXB0b3IgPSAhIW9wdGlvbnMuZGlzY2FyZERlc2NyaXB0b3I7XG4gIG9wdGlvbnMudW5zYWZlQ2xlYW51cCA9ICEhb3B0aW9ucy51bnNhZmVDbGVhbnVwO1xuXG4gIC8vIGZvciBjb21wbGV0ZW5lc3MnIHNha2Ugb25seSwgYWxzbyBrZWVwIChtdWx0aXBsZSkgYmxhbmtzIGlmIHRoZSB1c2VyLCBwdXJwb3J0ZWRseSBzYW5lLCByZXF1ZXN0cyB1cyB0b1xuICBvcHRpb25zLnByZWZpeCA9IF9pc1VuZGVmaW5lZChvcHRpb25zLnByZWZpeCkgPyAnJyA6IG9wdGlvbnMucHJlZml4O1xuICBvcHRpb25zLnBvc3RmaXggPSBfaXNVbmRlZmluZWQob3B0aW9ucy5wb3N0Zml4KSA/ICcnIDogb3B0aW9ucy5wb3N0Zml4O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHJlbGF0aXZlIGRpcmVjdG9yeSB0byB0bXBEaXIuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldFJlbGF0aXZlUGF0aChvcHRpb24sIG5hbWUsIHRtcERpciwgY2IpIHtcbiAgaWYgKF9pc1VuZGVmaW5lZChuYW1lKSkgcmV0dXJuIGNiKG51bGwpO1xuXG4gIF9yZXNvbHZlUGF0aChuYW1lLCB0bXBEaXIsIGZ1bmN0aW9uIChlcnIsIHJlc29sdmVkUGF0aCkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgY29uc3QgcmVsYXRpdmVQYXRoID0gcGF0aC5yZWxhdGl2ZSh0bXBEaXIsIHJlc29sdmVkUGF0aCk7XG5cbiAgICBpZiAoIXJlc29sdmVkUGF0aC5zdGFydHNXaXRoKHRtcERpcikpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoYCR7b3B0aW9ufSBvcHRpb24gbXVzdCBiZSByZWxhdGl2ZSB0byBcIiR7dG1wRGlyfVwiLCBmb3VuZCBcIiR7cmVsYXRpdmVQYXRofVwiLmApKTtcbiAgICB9XG5cbiAgICBjYihudWxsLCByZWxhdGl2ZVBhdGgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSByZWxhdGl2ZSBwYXRoIHRvIHRtcERpci5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0UmVsYXRpdmVQYXRoU3luYyhvcHRpb24sIG5hbWUsIHRtcERpcikge1xuICBpZiAoX2lzVW5kZWZpbmVkKG5hbWUpKSByZXR1cm47XG5cbiAgY29uc3QgcmVzb2x2ZWRQYXRoID0gX3Jlc29sdmVQYXRoU3luYyhuYW1lLCB0bXBEaXIpO1xuICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKHRtcERpciwgcmVzb2x2ZWRQYXRoKTtcblxuICBpZiAoIXJlc29sdmVkUGF0aC5zdGFydHNXaXRoKHRtcERpcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B0aW9ufSBvcHRpb24gbXVzdCBiZSByZWxhdGl2ZSB0byBcIiR7dG1wRGlyfVwiLCBmb3VuZCBcIiR7cmVsYXRpdmVQYXRofVwiLmApO1xuICB9XG5cbiAgcmV0dXJuIHJlbGF0aXZlUGF0aDtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBvcHRpb25zIGFyZSB2YWxpZCwgYWxzbyBzYW5pdGl6ZXMgb3B0aW9ucyBhbmQgcHJvdmlkZXMgc2FuZSBkZWZhdWx0cyBmb3IgbWlzc2luZ1xuICogb3B0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfYXNzZXJ0QW5kU2FuaXRpemVPcHRpb25zKG9wdGlvbnMsIGNiKSB7XG4gIF9nZXRUbXBEaXIob3B0aW9ucywgZnVuY3Rpb24gKGVyciwgdG1wRGlyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICBvcHRpb25zLnRtcGRpciA9IHRtcERpcjtcblxuICAgIHRyeSB7XG4gICAgICBfYXNzZXJ0T3B0aW9uc0Jhc2Uob3B0aW9ucywgdG1wRGlyKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihlcnIpO1xuICAgIH1cblxuICAgIC8vIHNhbml0aXplIGRpciwgYWxzbyBrZWVwIChtdWx0aXBsZSkgYmxhbmtzIGlmIHRoZSB1c2VyLCBwdXJwb3J0ZWRseSBzYW5lLCByZXF1ZXN0cyB1cyB0b1xuICAgIF9nZXRSZWxhdGl2ZVBhdGgoJ2RpcicsIG9wdGlvbnMuZGlyLCB0bXBEaXIsIGZ1bmN0aW9uIChlcnIsIGRpcikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIG9wdGlvbnMuZGlyID0gX2lzVW5kZWZpbmVkKGRpcikgPyAnJyA6IGRpcjtcblxuICAgICAgLy8gc2FuaXRpemUgZnVydGhlciBpZiB0ZW1wbGF0ZSBpcyByZWxhdGl2ZSB0byBvcHRpb25zLmRpclxuICAgICAgX2dldFJlbGF0aXZlUGF0aCgndGVtcGxhdGUnLCBvcHRpb25zLnRlbXBsYXRlLCB0bXBEaXIsIGZ1bmN0aW9uIChlcnIsIHRlbXBsYXRlKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICAgIG9wdGlvbnMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgICAgICBjYihudWxsLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBvcHRpb25zIGFyZSB2YWxpZCwgYWxzbyBzYW5pdGl6ZXMgb3B0aW9ucyBhbmQgcHJvdmlkZXMgc2FuZSBkZWZhdWx0cyBmb3IgbWlzc2luZ1xuICogb3B0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfYXNzZXJ0QW5kU2FuaXRpemVPcHRpb25zU3luYyhvcHRpb25zKSB7XG4gIGNvbnN0IHRtcERpciA9IChvcHRpb25zLnRtcGRpciA9IF9nZXRUbXBEaXJTeW5jKG9wdGlvbnMpKTtcblxuICBfYXNzZXJ0T3B0aW9uc0Jhc2Uob3B0aW9ucywgdG1wRGlyKTtcblxuICBjb25zdCBkaXIgPSBfZ2V0UmVsYXRpdmVQYXRoU3luYygnZGlyJywgb3B0aW9ucy5kaXIsIHRtcERpcik7XG4gIG9wdGlvbnMuZGlyID0gX2lzVW5kZWZpbmVkKGRpcikgPyAnJyA6IGRpcjtcblxuICBvcHRpb25zLnRlbXBsYXRlID0gX2dldFJlbGF0aXZlUGF0aFN5bmMoJ3RlbXBsYXRlJywgb3B0aW9ucy50ZW1wbGF0ZSwgdG1wRGlyKTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHRlc3RpbmcgYWdhaW5zdCBFQkFERiB0byBjb21wZW5zYXRlIGNoYW5nZXMgbWFkZSB0byBOb2RlIDcueCB1bmRlciBXaW5kb3dzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc0VCQURGKGVycm9yKSB7XG4gIHJldHVybiBfaXNFeHBlY3RlZEVycm9yKGVycm9yLCAtRUJBREYsICdFQkFERicpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgdGVzdGluZyBhZ2FpbnN0IEVOT0VOVCB0byBjb21wZW5zYXRlIGNoYW5nZXMgbWFkZSB0byBOb2RlIDcueCB1bmRlciBXaW5kb3dzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc0VOT0VOVChlcnJvcikge1xuICByZXR1cm4gX2lzRXhwZWN0ZWRFcnJvcihlcnJvciwgLUVOT0VOVCwgJ0VOT0VOVCcpO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgZXhwZWN0ZWQgZXJyb3IgY29kZSBtYXRjaGVzIHRoZSBhY3R1YWwgY29kZSBhbmQgZXJybm8sXG4gKiB3aGljaCB3aWxsIGRpZmZlciBiZXR3ZWVuIHRoZSBzdXBwb3J0ZWQgbm9kZSB2ZXJzaW9ucy5cbiAqXG4gKiAtIE5vZGUgPj0gNy4wOlxuICogICBlcnJvci5jb2RlIHtzdHJpbmd9XG4gKiAgIGVycm9yLmVycm5vIHtudW1iZXJ9IGFueSBudW1lcmljYWwgdmFsdWUgd2lsbCBiZSBuZWdhdGVkXG4gKlxuICogQ0FWRUFUXG4gKlxuICogT24gd2luZG93cywgdGhlIGVycm5vIGZvciBFQkFERiBpcyAtNDA4MyBidXQgb3MuY29uc3RhbnRzLmVycm5vLkVCQURGIGlzIGRpZmZlcmVudCBhbmQgd2UgbXVzdCBhc3N1bWUgdGhhdCBFTk9FTlRcbiAqIGlzIG5vIGRpZmZlcmVudCBoZXJlLlxuICpcbiAqIEBwYXJhbSB7U3lzdGVtRXJyb3J9IGVycm9yXG4gKiBAcGFyYW0ge251bWJlcn0gZXJybm9cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNFeHBlY3RlZEVycm9yKGVycm9yLCBlcnJubywgY29kZSkge1xuICByZXR1cm4gSVNfV0lOMzIgPyBlcnJvci5jb2RlID09PSBjb2RlIDogZXJyb3IuY29kZSA9PT0gY29kZSAmJiBlcnJvci5lcnJubyA9PT0gZXJybm87XG59XG5cbi8qKlxuICogU2V0cyB0aGUgZ3JhY2VmdWwgY2xlYW51cC5cbiAqXG4gKiBJZiBncmFjZWZ1bCBjbGVhbnVwIGlzIHNldCwgdG1wIHdpbGwgcmVtb3ZlIGFsbCBjb250cm9sbGVkIHRlbXBvcmFyeSBvYmplY3RzIG9uIHByb2Nlc3MgZXhpdCwgb3RoZXJ3aXNlIHRoZVxuICogdGVtcG9yYXJ5IG9iamVjdHMgd2lsbCByZW1haW4gaW4gcGxhY2UsIHdhaXRpbmcgdG8gYmUgY2xlYW5lZCB1cCBvbiBzeXN0ZW0gcmVzdGFydCBvciBvdGhlcndpc2Ugc2NoZWR1bGVkIHRlbXBvcmFyeVxuICogb2JqZWN0IHJlbW92YWxzLlxuICovXG5mdW5jdGlvbiBzZXRHcmFjZWZ1bENsZWFudXAoKSB7XG4gIF9ncmFjZWZ1bENsZWFudXAgPSB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBjb25maWd1cmVkIHRtcCBkaXIgZnJvbSBvcy50bXBkaXIoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0VG1wRGlyKG9wdGlvbnMsIGNiKSB7XG4gIHJldHVybiBmcy5yZWFscGF0aCgob3B0aW9ucyAmJiBvcHRpb25zLnRtcGRpcikgfHwgb3MudG1wZGlyKCksIGNiKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgY29uZmlndXJlZCB0bXAgZGlyIGZyb20gb3MudG1wZGlyKCkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldFRtcERpclN5bmMob3B0aW9ucykge1xuICByZXR1cm4gZnMucmVhbHBhdGhTeW5jKChvcHRpb25zICYmIG9wdGlvbnMudG1wZGlyKSB8fCBvcy50bXBkaXIoKSk7XG59XG5cbi8vIEluc3RhbGwgcHJvY2VzcyBleGl0IGxpc3RlbmVyXG5wcm9jZXNzLmFkZExpc3RlbmVyKEVYSVQsIF9nYXJiYWdlQ29sbGVjdG9yKTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0ga2VlcCB0aGUgdGVtcG9yYXJ5IG9iamVjdCAoZmlsZSBvciBkaXIpIHdpbGwgbm90IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IHRyaWVzIHRoZSBudW1iZXIgb2YgdHJpZXMgYmVmb3JlIGdpdmUgdXAgdGhlIG5hbWUgZ2VuZXJhdGlvblxuICogQHByb3BlcnR5ICg/aW50KSBtb2RlIHRoZSBhY2Nlc3MgbW9kZSwgZGVmYXVsdHMgYXJlIDBvNzAwIGZvciBkaXJlY3RvcmllcyBhbmQgMG82MDAgZm9yIGZpbGVzXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHRlbXBsYXRlIHRoZSBcIm1rc3RlbXBcIiBsaWtlIGZpbGVuYW1lIHRlbXBsYXRlXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IG5hbWUgZml4ZWQgbmFtZSByZWxhdGl2ZSB0byB0bXBkaXIgb3IgdGhlIHNwZWNpZmllZCBkaXIgb3B0aW9uXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGRpciB0bXAgZGlyZWN0b3J5IHJlbGF0aXZlIHRvIHRoZSByb290IHRtcCBkaXJlY3RvcnkgaW4gdXNlXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHByZWZpeCBwcmVmaXggZm9yIHRoZSBnZW5lcmF0ZWQgbmFtZVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBwb3N0Zml4IHBvc3RmaXggZm9yIHRoZSBnZW5lcmF0ZWQgbmFtZVxuICogQHByb3BlcnR5IHs/c3RyaW5nfSB0bXBkaXIgdGhlIHJvb3QgdG1wIGRpcmVjdG9yeSB3aGljaCBvdmVycmlkZXMgdGhlIG9zIHRtcGRpclxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gdW5zYWZlQ2xlYW51cCByZWN1cnNpdmVseSByZW1vdmVzIHRoZSBjcmVhdGVkIHRlbXBvcmFyeSBkaXJlY3RvcnksIGV2ZW4gd2hlbiBpdCdzIG5vdCBlbXB0eVxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gZGV0YWNoRGVzY3JpcHRvciBkZXRhY2hlcyB0aGUgZmlsZSBkZXNjcmlwdG9yLCBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIGNsb3NpbmcgdGhlIGZpbGUsIHRtcCB3aWxsIG5vIGxvbmdlciB0cnkgY2xvc2luZyB0aGUgZmlsZSBkdXJpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBkaXNjYXJkRGVzY3JpcHRvciBkaXNjYXJkcyB0aGUgZmlsZSBkZXNjcmlwdG9yIChjbG9zZXMgZmlsZSwgZmQgaXMgLTEpLCB0bXAgd2lsbCBubyBsb25nZXIgdHJ5IGNsb3NpbmcgdGhlIGZpbGUgZHVyaW5nIGdhcmJhZ2UgY29sbGVjdGlvblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmlsZVN5bmNPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmQgdGhlIGZpbGUgZGVzY3JpcHRvciBvciAtMSBpZiB0aGUgZmQgaGFzIGJlZW4gZGlzY2FyZGVkXG4gKiBAcHJvcGVydHkge2ZpbGVDYWxsYmFja30gcmVtb3ZlQ2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgZmlsZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRGlyU3luY09iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeVxuICogQHByb3BlcnR5IHtmaWxlQ2FsbGJhY2t9IHJlbW92ZUNhbGxiYWNrIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byByZW1vdmUgdGhlIGRpcmVjdG9yeVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIHRtcE5hbWVDYWxsYmFja1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciB0aGUgZXJyb3Igb2JqZWN0IGlmIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSB0ZW1wb3JhcnkgZmlsZSBuYW1lXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZmlsZUNhbGxiYWNrXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCB0aGUgZmlsZSBkZXNjcmlwdG9yIG9yIC0xIGlmIHRoZSBmZCBoYWQgYmVlbiBkaXNjYXJkZWRcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrfSBmbiB0aGUgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGZpbGVDYWxsYmFja1N5bmNcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGZkIHRoZSBmaWxlIGRlc2NyaXB0b3Igb3IgLTEgaWYgdGhlIGZkIGhhZCBiZWVuIGRpc2NhcmRlZFxuICogQHBhcmFtIHtjbGVhbnVwQ2FsbGJhY2tTeW5jfSBmbiB0aGUgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGRpckNhbGxiYWNrXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrfSBmbiB0aGUgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGRpckNhbGxiYWNrU3luY1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciB0aGUgZXJyb3Igb2JqZWN0IGlmIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSB0ZW1wb3JhcnkgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja1N5bmN9IGZuIHRoZSBjbGVhbnVwIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSB0ZW1wb3JhcnkgY3JlYXRlZCBmaWxlIG9yIGRpcmVjdG9yeS5cbiAqXG4gKiBAY2FsbGJhY2sgY2xlYW51cENhbGxiYWNrXG4gKiBAcGFyYW0ge3NpbXBsZUNhbGxiYWNrfSBbbmV4dF0gZnVuY3Rpb24gdG8gY2FsbCB3aGVuZXZlciB0aGUgdG1wIG9iamVjdCBuZWVkcyB0byBiZSByZW1vdmVkXG4gKi9cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSB0ZW1wb3JhcnkgY3JlYXRlZCBmaWxlIG9yIGRpcmVjdG9yeS5cbiAqXG4gKiBAY2FsbGJhY2sgY2xlYW51cENhbGxiYWNrU3luY1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGZ1bmN0aW9uIGNvbXBvc2l0aW9uLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3Jhc3ppL25vZGUtdG1wL2lzc3Vlcy81N3xyYXN6aS9ub2RlLXRtcCM1N31cbiAqXG4gKiBAY2FsbGJhY2sgc2ltcGxlQ2FsbGJhY2tcbiAqL1xuXG4vLyBleHBvcnRpbmcgYWxsIHRoZSBuZWVkZWQgbWV0aG9kc1xuXG4vLyBldmFsdWF0ZSBfZ2V0VG1wRGlyKCkgbGF6aWx5LCBtYWlubHkgZm9yIHNpbXBsaWZ5aW5nIHRlc3RpbmcgYnV0IGl0IGFsc28gd2lsbFxuLy8gYWxsb3cgdXNlcnMgdG8gcmVjb25maWd1cmUgdGhlIHRlbXBvcmFyeSBkaXJlY3Rvcnlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ3RtcGRpcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9nZXRUbXBEaXJTeW5jKCk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy5kaXIgPSBkaXI7XG5tb2R1bGUuZXhwb3J0cy5kaXJTeW5jID0gZGlyU3luYztcblxubW9kdWxlLmV4cG9ydHMuZmlsZSA9IGZpbGU7XG5tb2R1bGUuZXhwb3J0cy5maWxlU3luYyA9IGZpbGVTeW5jO1xuXG5tb2R1bGUuZXhwb3J0cy50bXBOYW1lID0gdG1wTmFtZTtcbm1vZHVsZS5leHBvcnRzLnRtcE5hbWVTeW5jID0gdG1wTmFtZVN5bmM7XG5cbm1vZHVsZS5leHBvcnRzLnNldEdyYWNlZnVsQ2xlYW51cCA9IHNldEdyYWNlZnVsQ2xlYW51cDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/tmp@0.2.5/node_modules/tmp/lib/tmp.js\n");

/***/ })

};
;