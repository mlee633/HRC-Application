/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/readdir-glob@1.1.3";
exports.ids = ["vendor-chunks/readdir-glob@1.1.3"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/readdir-glob@1.1.3/node_modules/readdir-glob/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/readdir-glob@1.1.3/node_modules/readdir-glob/index.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = readdirGlob;\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { EventEmitter } = __webpack_require__(/*! events */ \"events\");\nconst { Minimatch } = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/minimatch.js\");\nconst { resolve } = __webpack_require__(/*! path */ \"path\");\n\nfunction readdir(dir, strict) {\n  return new Promise((resolve, reject) => {\n    fs.readdir(dir, {withFileTypes: true} ,(err, files) => {\n      if(err) {\n        switch (err.code) {\n          case 'ENOTDIR':      // Not a directory\n            if(strict) {\n              reject(err);\n            } else {\n              resolve([]);\n            }\n            break;\n          case 'ENOTSUP':      // Operation not supported\n          case 'ENOENT':       // No such file or directory\n          case 'ENAMETOOLONG': // Filename too long\n          case 'UNKNOWN':\n            resolve([]);\n            break;\n          case 'ELOOP':        // Too many levels of symbolic links\n          default:\n            reject(err);\n            break;\n        }\n      } else {\n        resolve(files);\n      }\n    });\n  });\n}\nfunction stat(file, followSymlinks) {\n  return new Promise((resolve, reject) => {\n    const statFunc = followSymlinks ? fs.stat : fs.lstat;\n    statFunc(file, (err, stats) => {\n      if(err) {\n        switch (err.code) {\n          case 'ENOENT':\n            if(followSymlinks) {\n              // Fallback to lstat to handle broken links as files\n              resolve(stat(file, false)); \n            } else {\n              resolve(null);\n            }\n            break;\n          default:\n            resolve(null);\n            break;\n        }\n      } else {\n        resolve(stats);\n      }\n    });\n  });\n}\n\nasync function* exploreWalkAsync(dir, path, followSymlinks, useStat, shouldSkip, strict) {\n  let files = await readdir(path + dir, strict);\n  for(const file of files) {\n    let name = file.name;\n    if(name === undefined) {\n      // undefined file.name means the `withFileTypes` options is not supported by node\n      // we have to call the stat function to know if file is directory or not.\n      name = file;\n      useStat = true;\n    }\n    const filename = dir + '/' + name;\n    const relative = filename.slice(1); // Remove the leading /\n    const absolute = path + '/' + relative;\n    let stats = null;\n    if(useStat || followSymlinks) {\n      stats = await stat(absolute, followSymlinks);\n    }\n    if(!stats && file.name !== undefined) {\n      stats = file;\n    }\n    if(stats === null) {\n      stats = { isDirectory: () => false };\n    }\n\n    if(stats.isDirectory()) {\n      if(!shouldSkip(relative)) {\n        yield {relative, absolute, stats};\n        yield* exploreWalkAsync(filename, path, followSymlinks, useStat, shouldSkip, false);\n      }\n    } else {\n      yield {relative, absolute, stats};\n    }\n  }\n}\nasync function* explore(path, followSymlinks, useStat, shouldSkip) {\n  yield* exploreWalkAsync('', path, followSymlinks, useStat, shouldSkip, true);\n}\n\n\nfunction readOptions(options) {\n  return {\n    pattern: options.pattern,\n    dot: !!options.dot,\n    noglobstar: !!options.noglobstar,\n    matchBase: !!options.matchBase,\n    nocase: !!options.nocase,\n    ignore: options.ignore,\n    skip: options.skip,\n\n    follow: !!options.follow,\n    stat: !!options.stat,\n    nodir: !!options.nodir,\n    mark: !!options.mark,\n    silent: !!options.silent,\n    absolute: !!options.absolute\n  };\n}\n\nclass ReaddirGlob extends EventEmitter {\n  constructor(cwd, options, cb) {\n    super();\n    if(typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.options = readOptions(options ||Â {});\n  \n    this.matchers = [];\n    if(this.options.pattern) {\n      const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];\n      this.matchers = matchers.map( m =>\n        new Minimatch(m, {\n          dot: this.options.dot,\n          noglobstar:this.options.noglobstar,\n          matchBase:this.options.matchBase,\n          nocase:this.options.nocase\n        })\n      );\n    }\n  \n    this.ignoreMatchers = [];\n    if(this.options.ignore) {\n      const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];\n      this.ignoreMatchers = ignorePatterns.map( ignore =>\n        new Minimatch(ignore, {dot: true})\n      );\n    }\n  \n    this.skipMatchers = [];\n    if(this.options.skip) {\n      const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];\n      this.skipMatchers = skipPatterns.map( skip =>\n        new Minimatch(skip, {dot: true})\n      );\n    }\n\n    this.iterator = explore(resolve(cwd || '.'), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));\n    this.paused = false;\n    this.inactive = false;\n    this.aborted = false;\n  \n    if(cb) {\n      this._matches = []; \n      this.on('match', match => this._matches.push(this.options.absolute ? match.absolute : match.relative));\n      this.on('error', err => cb(err));\n      this.on('end', () => cb(null, this._matches));\n    }\n\n    setTimeout( () => this._next(), 0);\n  }\n\n  _shouldSkipDirectory(relative) {\n    //console.log(relative, this.skipMatchers.some(m => m.match(relative)));\n    return this.skipMatchers.some(m => m.match(relative));\n  }\n\n  _fileMatches(relative, isDirectory) {\n    const file = relative + (isDirectory ? '/' : '');\n    return (this.matchers.length === 0 || this.matchers.some(m => m.match(file)))\n      && !this.ignoreMatchers.some(m => m.match(file))\n      && (!this.options.nodir || !isDirectory);\n  }\n\n  _next() {\n    if(!this.paused && !this.aborted) {\n      this.iterator.next()\n      .then((obj)=> {\n        if(!obj.done) {\n          const isDirectory = obj.value.stats.isDirectory();\n          if(this._fileMatches(obj.value.relative, isDirectory )) {\n            let relative = obj.value.relative;\n            let absolute = obj.value.absolute;\n            if(this.options.mark && isDirectory) {\n              relative += '/';\n              absolute += '/';\n            }\n            if(this.options.stat) {\n              this.emit('match', {relative, absolute, stat:obj.value.stats});\n            } else {\n              this.emit('match', {relative, absolute});\n            }\n          }\n          this._next(this.iterator);\n        } else {\n          this.emit('end');\n        }\n      })\n      .catch((err) => {\n        this.abort();\n        this.emit('error', err);\n        if(!err.code && !this.options.silent) {\n          console.error(err);\n        }\n      });\n    } else {\n      this.inactive = true;\n    }\n  }\n\n  abort() {\n    this.aborted = true;\n  }\n\n  pause() {\n    this.paused = true;\n  }\n\n  resume() {\n    this.paused = false;\n    if(this.inactive) {\n      this.inactive = false;\n      this._next();\n    }\n  }\n}\n\n\nfunction readdirGlob(pattern, options, cb) {\n  return new ReaddirGlob(pattern, options, cb);\n}\nreaddirGlob.ReaddirGlob = ReaddirGlob;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhZGRpci1nbG9iQDEuMS4zL25vZGVfbW9kdWxlcy9yZWFkZGlyLWdsb2IvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUN6QyxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGlHQUFXO0FBQ3pDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsa0JBQU07O0FBRWxDO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlDQUF5QztBQUMzRSxjQUFjO0FBQ2Qsa0NBQWtDLG1CQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvaWxlZTAwL0Rlc2t0b3AvSFJDLUFwcGxpY2F0aW9uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFkZGlyLWdsb2JAMS4xLjMvbm9kZV9tb2R1bGVzL3JlYWRkaXItZ2xvYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlYWRkaXJHbG9iO1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCB7IE1pbmltYXRjaCB9ID0gcmVxdWlyZSgnbWluaW1hdGNoJyk7XG5jb25zdCB7IHJlc29sdmUgfSA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuZnVuY3Rpb24gcmVhZGRpcihkaXIsIHN0cmljdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLnJlYWRkaXIoZGlyLCB7d2l0aEZpbGVUeXBlczogdHJ1ZX0gLChlcnIsIGZpbGVzKSA9PiB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICAgIGNhc2UgJ0VOT1RESVInOiAgICAgIC8vIE5vdCBhIGRpcmVjdG9yeVxuICAgICAgICAgICAgaWYoc3RyaWN0KSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdFTk9UU1VQJzogICAgICAvLyBPcGVyYXRpb24gbm90IHN1cHBvcnRlZFxuICAgICAgICAgIGNhc2UgJ0VOT0VOVCc6ICAgICAgIC8vIE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcbiAgICAgICAgICBjYXNlICdFTkFNRVRPT0xPTkcnOiAvLyBGaWxlbmFtZSB0b28gbG9uZ1xuICAgICAgICAgIGNhc2UgJ1VOS05PV04nOlxuICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdFTE9PUCc6ICAgICAgICAvLyBUb28gbWFueSBsZXZlbHMgb2Ygc3ltYm9saWMgbGlua3NcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShmaWxlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc3RhdChmaWxlLCBmb2xsb3dTeW1saW5rcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHN0YXRGdW5jID0gZm9sbG93U3ltbGlua3MgPyBmcy5zdGF0IDogZnMubHN0YXQ7XG4gICAgc3RhdEZ1bmMoZmlsZSwgKGVyciwgc3RhdHMpID0+IHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgICAgY2FzZSAnRU5PRU5UJzpcbiAgICAgICAgICAgIGlmKGZvbGxvd1N5bWxpbmtzKSB7XG4gICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGxzdGF0IHRvIGhhbmRsZSBicm9rZW4gbGlua3MgYXMgZmlsZXNcbiAgICAgICAgICAgICAgcmVzb2x2ZShzdGF0KGZpbGUsIGZhbHNlKSk7IFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoc3RhdHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24qIGV4cGxvcmVXYWxrQXN5bmMoZGlyLCBwYXRoLCBmb2xsb3dTeW1saW5rcywgdXNlU3RhdCwgc2hvdWxkU2tpcCwgc3RyaWN0KSB7XG4gIGxldCBmaWxlcyA9IGF3YWl0IHJlYWRkaXIocGF0aCArIGRpciwgc3RyaWN0KTtcbiAgZm9yKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICBsZXQgbmFtZSA9IGZpbGUubmFtZTtcbiAgICBpZihuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHVuZGVmaW5lZCBmaWxlLm5hbWUgbWVhbnMgdGhlIGB3aXRoRmlsZVR5cGVzYCBvcHRpb25zIGlzIG5vdCBzdXBwb3J0ZWQgYnkgbm9kZVxuICAgICAgLy8gd2UgaGF2ZSB0byBjYWxsIHRoZSBzdGF0IGZ1bmN0aW9uIHRvIGtub3cgaWYgZmlsZSBpcyBkaXJlY3Rvcnkgb3Igbm90LlxuICAgICAgbmFtZSA9IGZpbGU7XG4gICAgICB1c2VTdGF0ID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZmlsZW5hbWUgPSBkaXIgKyAnLycgKyBuYW1lO1xuICAgIGNvbnN0IHJlbGF0aXZlID0gZmlsZW5hbWUuc2xpY2UoMSk7IC8vIFJlbW92ZSB0aGUgbGVhZGluZyAvXG4gICAgY29uc3QgYWJzb2x1dGUgPSBwYXRoICsgJy8nICsgcmVsYXRpdmU7XG4gICAgbGV0IHN0YXRzID0gbnVsbDtcbiAgICBpZih1c2VTdGF0IHx8IGZvbGxvd1N5bWxpbmtzKSB7XG4gICAgICBzdGF0cyA9IGF3YWl0IHN0YXQoYWJzb2x1dGUsIGZvbGxvd1N5bWxpbmtzKTtcbiAgICB9XG4gICAgaWYoIXN0YXRzICYmIGZpbGUubmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGF0cyA9IGZpbGU7XG4gICAgfVxuICAgIGlmKHN0YXRzID09PSBudWxsKSB7XG4gICAgICBzdGF0cyA9IHsgaXNEaXJlY3Rvcnk6ICgpID0+IGZhbHNlIH07XG4gICAgfVxuXG4gICAgaWYoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgaWYoIXNob3VsZFNraXAocmVsYXRpdmUpKSB7XG4gICAgICAgIHlpZWxkIHtyZWxhdGl2ZSwgYWJzb2x1dGUsIHN0YXRzfTtcbiAgICAgICAgeWllbGQqIGV4cGxvcmVXYWxrQXN5bmMoZmlsZW5hbWUsIHBhdGgsIGZvbGxvd1N5bWxpbmtzLCB1c2VTdGF0LCBzaG91bGRTa2lwLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHlpZWxkIHtyZWxhdGl2ZSwgYWJzb2x1dGUsIHN0YXRzfTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uKiBleHBsb3JlKHBhdGgsIGZvbGxvd1N5bWxpbmtzLCB1c2VTdGF0LCBzaG91bGRTa2lwKSB7XG4gIHlpZWxkKiBleHBsb3JlV2Fsa0FzeW5jKCcnLCBwYXRoLCBmb2xsb3dTeW1saW5rcywgdXNlU3RhdCwgc2hvdWxkU2tpcCwgdHJ1ZSk7XG59XG5cblxuZnVuY3Rpb24gcmVhZE9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHBhdHRlcm46IG9wdGlvbnMucGF0dGVybixcbiAgICBkb3Q6ICEhb3B0aW9ucy5kb3QsXG4gICAgbm9nbG9ic3RhcjogISFvcHRpb25zLm5vZ2xvYnN0YXIsXG4gICAgbWF0Y2hCYXNlOiAhIW9wdGlvbnMubWF0Y2hCYXNlLFxuICAgIG5vY2FzZTogISFvcHRpb25zLm5vY2FzZSxcbiAgICBpZ25vcmU6IG9wdGlvbnMuaWdub3JlLFxuICAgIHNraXA6IG9wdGlvbnMuc2tpcCxcblxuICAgIGZvbGxvdzogISFvcHRpb25zLmZvbGxvdyxcbiAgICBzdGF0OiAhIW9wdGlvbnMuc3RhdCxcbiAgICBub2RpcjogISFvcHRpb25zLm5vZGlyLFxuICAgIG1hcms6ICEhb3B0aW9ucy5tYXJrLFxuICAgIHNpbGVudDogISFvcHRpb25zLnNpbGVudCxcbiAgICBhYnNvbHV0ZTogISFvcHRpb25zLmFic29sdXRlXG4gIH07XG59XG5cbmNsYXNzIFJlYWRkaXJHbG9iIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoY3dkLCBvcHRpb25zLCBjYikge1xuICAgIHN1cGVyKCk7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IHJlYWRPcHRpb25zKG9wdGlvbnMgfHzCoHt9KTtcbiAgXG4gICAgdGhpcy5tYXRjaGVycyA9IFtdO1xuICAgIGlmKHRoaXMub3B0aW9ucy5wYXR0ZXJuKSB7XG4gICAgICBjb25zdCBtYXRjaGVycyA9IEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnBhdHRlcm4pID8gdGhpcy5vcHRpb25zLnBhdHRlcm4gOiBbdGhpcy5vcHRpb25zLnBhdHRlcm5dO1xuICAgICAgdGhpcy5tYXRjaGVycyA9IG1hdGNoZXJzLm1hcCggbSA9PlxuICAgICAgICBuZXcgTWluaW1hdGNoKG0sIHtcbiAgICAgICAgICBkb3Q6IHRoaXMub3B0aW9ucy5kb3QsXG4gICAgICAgICAgbm9nbG9ic3Rhcjp0aGlzLm9wdGlvbnMubm9nbG9ic3RhcixcbiAgICAgICAgICBtYXRjaEJhc2U6dGhpcy5vcHRpb25zLm1hdGNoQmFzZSxcbiAgICAgICAgICBub2Nhc2U6dGhpcy5vcHRpb25zLm5vY2FzZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIFxuICAgIHRoaXMuaWdub3JlTWF0Y2hlcnMgPSBbXTtcbiAgICBpZih0aGlzLm9wdGlvbnMuaWdub3JlKSB7XG4gICAgICBjb25zdCBpZ25vcmVQYXR0ZXJucyA9IEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmlnbm9yZSkgPyB0aGlzLm9wdGlvbnMuaWdub3JlIDogW3RoaXMub3B0aW9ucy5pZ25vcmVdO1xuICAgICAgdGhpcy5pZ25vcmVNYXRjaGVycyA9IGlnbm9yZVBhdHRlcm5zLm1hcCggaWdub3JlID0+XG4gICAgICAgIG5ldyBNaW5pbWF0Y2goaWdub3JlLCB7ZG90OiB0cnVlfSlcbiAgICAgICk7XG4gICAgfVxuICBcbiAgICB0aGlzLnNraXBNYXRjaGVycyA9IFtdO1xuICAgIGlmKHRoaXMub3B0aW9ucy5za2lwKSB7XG4gICAgICBjb25zdCBza2lwUGF0dGVybnMgPSBBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5za2lwKSA/IHRoaXMub3B0aW9ucy5za2lwIDogW3RoaXMub3B0aW9ucy5za2lwXTtcbiAgICAgIHRoaXMuc2tpcE1hdGNoZXJzID0gc2tpcFBhdHRlcm5zLm1hcCggc2tpcCA9PlxuICAgICAgICBuZXcgTWluaW1hdGNoKHNraXAsIHtkb3Q6IHRydWV9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLml0ZXJhdG9yID0gZXhwbG9yZShyZXNvbHZlKGN3ZCB8fCAnLicpLCB0aGlzLm9wdGlvbnMuZm9sbG93LCB0aGlzLm9wdGlvbnMuc3RhdCwgdGhpcy5fc2hvdWxkU2tpcERpcmVjdG9yeS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZTtcbiAgXG4gICAgaWYoY2IpIHtcbiAgICAgIHRoaXMuX21hdGNoZXMgPSBbXTsgXG4gICAgICB0aGlzLm9uKCdtYXRjaCcsIG1hdGNoID0+IHRoaXMuX21hdGNoZXMucHVzaCh0aGlzLm9wdGlvbnMuYWJzb2x1dGUgPyBtYXRjaC5hYnNvbHV0ZSA6IG1hdGNoLnJlbGF0aXZlKSk7XG4gICAgICB0aGlzLm9uKCdlcnJvcicsIGVyciA9PiBjYihlcnIpKTtcbiAgICAgIHRoaXMub24oJ2VuZCcsICgpID0+IGNiKG51bGwsIHRoaXMuX21hdGNoZXMpKTtcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCAoKSA9PiB0aGlzLl9uZXh0KCksIDApO1xuICB9XG5cbiAgX3Nob3VsZFNraXBEaXJlY3RvcnkocmVsYXRpdmUpIHtcbiAgICAvL2NvbnNvbGUubG9nKHJlbGF0aXZlLCB0aGlzLnNraXBNYXRjaGVycy5zb21lKG0gPT4gbS5tYXRjaChyZWxhdGl2ZSkpKTtcbiAgICByZXR1cm4gdGhpcy5za2lwTWF0Y2hlcnMuc29tZShtID0+IG0ubWF0Y2gocmVsYXRpdmUpKTtcbiAgfVxuXG4gIF9maWxlTWF0Y2hlcyhyZWxhdGl2ZSwgaXNEaXJlY3RvcnkpIHtcbiAgICBjb25zdCBmaWxlID0gcmVsYXRpdmUgKyAoaXNEaXJlY3RvcnkgPyAnLycgOiAnJyk7XG4gICAgcmV0dXJuICh0aGlzLm1hdGNoZXJzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLm1hdGNoZXJzLnNvbWUobSA9PiBtLm1hdGNoKGZpbGUpKSlcbiAgICAgICYmICF0aGlzLmlnbm9yZU1hdGNoZXJzLnNvbWUobSA9PiBtLm1hdGNoKGZpbGUpKVxuICAgICAgJiYgKCF0aGlzLm9wdGlvbnMubm9kaXIgfHwgIWlzRGlyZWN0b3J5KTtcbiAgfVxuXG4gIF9uZXh0KCkge1xuICAgIGlmKCF0aGlzLnBhdXNlZCAmJiAhdGhpcy5hYm9ydGVkKSB7XG4gICAgICB0aGlzLml0ZXJhdG9yLm5leHQoKVxuICAgICAgLnRoZW4oKG9iaik9PiB7XG4gICAgICAgIGlmKCFvYmouZG9uZSkge1xuICAgICAgICAgIGNvbnN0IGlzRGlyZWN0b3J5ID0gb2JqLnZhbHVlLnN0YXRzLmlzRGlyZWN0b3J5KCk7XG4gICAgICAgICAgaWYodGhpcy5fZmlsZU1hdGNoZXMob2JqLnZhbHVlLnJlbGF0aXZlLCBpc0RpcmVjdG9yeSApKSB7XG4gICAgICAgICAgICBsZXQgcmVsYXRpdmUgPSBvYmoudmFsdWUucmVsYXRpdmU7XG4gICAgICAgICAgICBsZXQgYWJzb2x1dGUgPSBvYmoudmFsdWUuYWJzb2x1dGU7XG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMubWFyayAmJiBpc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICByZWxhdGl2ZSArPSAnLyc7XG4gICAgICAgICAgICAgIGFic29sdXRlICs9ICcvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5zdGF0KSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWF0Y2gnLCB7cmVsYXRpdmUsIGFic29sdXRlLCBzdGF0Om9iai52YWx1ZS5zdGF0c30pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtYXRjaCcsIHtyZWxhdGl2ZSwgYWJzb2x1dGV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbmV4dCh0aGlzLml0ZXJhdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5hYm9ydCgpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgaWYoIWVyci5jb2RlICYmICF0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgfVxuXG4gIHJlc3VtZSgpIHtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICAgIGlmKHRoaXMuaW5hY3RpdmUpIHtcbiAgICAgIHRoaXMuaW5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX25leHQoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiByZWFkZGlyR2xvYihwYXR0ZXJuLCBvcHRpb25zLCBjYikge1xuICByZXR1cm4gbmV3IFJlYWRkaXJHbG9iKHBhdHRlcm4sIG9wdGlvbnMsIGNiKTtcbn1cbnJlYWRkaXJHbG9iLlJlYWRkaXJHbG9iID0gUmVhZGRpckdsb2I7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/readdir-glob@1.1.3/node_modules/readdir-glob/index.js\n");

/***/ })

};
;