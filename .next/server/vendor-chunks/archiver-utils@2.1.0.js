/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/archiver-utils@2.1.0";
exports.ids = ["vendor-chunks/archiver-utils@2.1.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\r\n * archiver-utils\r\n *\r\n * Copyright (c) 2012-2014 Chris Talkington, contributors.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT\r\n */\r\nvar fs = __webpack_require__(/*! graceful-fs */ \"(rsc)/./node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\n\r\nvar flatten = __webpack_require__(/*! lodash.flatten */ \"(rsc)/./node_modules/.pnpm/lodash.flatten@4.4.0/node_modules/lodash.flatten/index.js\");\r\nvar difference = __webpack_require__(/*! lodash.difference */ \"(rsc)/./node_modules/.pnpm/lodash.difference@4.5.0/node_modules/lodash.difference/index.js\");\r\nvar union = __webpack_require__(/*! lodash.union */ \"(rsc)/./node_modules/.pnpm/lodash.union@4.6.0/node_modules/lodash.union/index.js\");\r\nvar isPlainObject = __webpack_require__(/*! lodash.isplainobject */ \"(rsc)/./node_modules/.pnpm/lodash.isplainobject@4.0.6/node_modules/lodash.isplainobject/index.js\");\r\n\r\nvar glob = __webpack_require__(/*! glob */ \"(rsc)/./node_modules/.pnpm/glob@7.2.3/node_modules/glob/glob.js\");\r\n\r\nvar file = module.exports = {};\r\n\r\nvar pathSeparatorRe = /[\\/\\\\]/g;\r\n\r\n// Process specified wildcard glob patterns or filenames against a\r\n// callback, excluding and uniquing files in the result set.\r\nvar processPatterns = function(patterns, fn) {\r\n  // Filepaths to return.\r\n  var result = [];\r\n  // Iterate over flattened patterns array.\r\n  flatten(patterns).forEach(function(pattern) {\r\n    // If the first character is ! it should be omitted\r\n    var exclusion = pattern.indexOf('!') === 0;\r\n    // If the pattern is an exclusion, remove the !\r\n    if (exclusion) { pattern = pattern.slice(1); }\r\n    // Find all matching files for this pattern.\r\n    var matches = fn(pattern);\r\n    if (exclusion) {\r\n      // If an exclusion, remove matching files.\r\n      result = difference(result, matches);\r\n    } else {\r\n      // Otherwise add matching files.\r\n      result = union(result, matches);\r\n    }\r\n  });\r\n  return result;\r\n};\r\n\r\n// True if the file path exists.\r\nfile.exists = function() {\r\n  var filepath = path.join.apply(path, arguments);\r\n  return fs.existsSync(filepath);\r\n};\r\n\r\n// Return an array of all file paths that match the given wildcard patterns.\r\nfile.expand = function(...args) {\r\n  // If the first argument is an options object, save those options to pass\r\n  // into the File.prototype.glob.sync method.\r\n  var options = isPlainObject(args[0]) ? args.shift() : {};\r\n  // Use the first argument if it's an Array, otherwise convert the arguments\r\n  // object to an array and use that.\r\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\r\n  // Return empty set if there are no patterns or filepaths.\r\n  if (patterns.length === 0) { return []; }\r\n  // Return all matching filepaths.\r\n  var matches = processPatterns(patterns, function(pattern) {\r\n    // Find all matching files for this pattern.\r\n    return glob.sync(pattern, options);\r\n  });\r\n  // Filter result set?\r\n  if (options.filter) {\r\n    matches = matches.filter(function(filepath) {\r\n      filepath = path.join(options.cwd || '', filepath);\r\n      try {\r\n        if (typeof options.filter === 'function') {\r\n          return options.filter(filepath);\r\n        } else {\r\n          // If the file is of the right type and exists, this should work.\r\n          return fs.statSync(filepath)[options.filter]();\r\n        }\r\n      } catch(e) {\r\n        // Otherwise, it's probably not the right type.\r\n        return false;\r\n      }\r\n    });\r\n  }\r\n  return matches;\r\n};\r\n\r\n// Build a multi task \"files\" object dynamically.\r\nfile.expandMapping = function(patterns, destBase, options) {\r\n  options = Object.assign({\r\n    rename: function(destBase, destPath) {\r\n      return path.join(destBase || '', destPath);\r\n    }\r\n  }, options);\r\n  var files = [];\r\n  var fileByDest = {};\r\n  // Find all files matching pattern, using passed-in options.\r\n  file.expand(options, patterns).forEach(function(src) {\r\n    var destPath = src;\r\n    // Flatten?\r\n    if (options.flatten) {\r\n      destPath = path.basename(destPath);\r\n    }\r\n    // Change the extension?\r\n    if (options.ext) {\r\n      destPath = destPath.replace(/(\\.[^\\/]*)?$/, options.ext);\r\n    }\r\n    // Generate destination filename.\r\n    var dest = options.rename(destBase, destPath, options);\r\n    // Prepend cwd to src path if necessary.\r\n    if (options.cwd) { src = path.join(options.cwd, src); }\r\n    // Normalize filepaths to be unix-style.\r\n    dest = dest.replace(pathSeparatorRe, '/');\r\n    src = src.replace(pathSeparatorRe, '/');\r\n    // Map correct src path to dest path.\r\n    if (fileByDest[dest]) {\r\n      // If dest already exists, push this src onto that dest's src array.\r\n      fileByDest[dest].src.push(src);\r\n    } else {\r\n      // Otherwise create a new src-dest file mapping object.\r\n      files.push({\r\n        src: [src],\r\n        dest: dest,\r\n      });\r\n      // And store a reference for later use.\r\n      fileByDest[dest] = files[files.length - 1];\r\n    }\r\n  });\r\n  return files;\r\n};\r\n\r\n// reusing bits of grunt's multi-task source normalization\r\nfile.normalizeFilesArray = function(data) {\r\n  var files = [];\r\n\r\n  data.forEach(function(obj) {\r\n    var prop;\r\n    if ('src' in obj || 'dest' in obj) {\r\n      files.push(obj);\r\n    }\r\n  });\r\n\r\n  if (files.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  files = _(files).chain().forEach(function(obj) {\r\n    if (!('src' in obj) || !obj.src) { return; }\r\n    // Normalize .src properties to flattened array.\r\n    if (Array.isArray(obj.src)) {\r\n      obj.src = flatten(obj.src);\r\n    } else {\r\n      obj.src = [obj.src];\r\n    }\r\n  }).map(function(obj) {\r\n    // Build options object, removing unwanted properties.\r\n    var expandOptions = Object.assign({}, obj);\r\n    delete expandOptions.src;\r\n    delete expandOptions.dest;\r\n\r\n    // Expand file mappings.\r\n    if (obj.expand) {\r\n      return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {\r\n        // Copy obj properties to result.\r\n        var result = Object.assign({}, obj);\r\n        // Make a clone of the orig obj available.\r\n        result.orig = Object.assign({}, obj);\r\n        // Set .src and .dest, processing both as templates.\r\n        result.src = mapObj.src;\r\n        result.dest = mapObj.dest;\r\n        // Remove unwanted properties.\r\n        ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function(prop) {\r\n          delete result[prop];\r\n        });\r\n        return result;\r\n      });\r\n    }\r\n\r\n    // Copy obj properties to result, adding an .orig property.\r\n    var result = Object.assign({}, obj);\r\n    // Make a clone of the orig obj available.\r\n    result.orig = Object.assign({}, obj);\r\n\r\n    if ('src' in result) {\r\n      // Expose an expand-on-demand getter method as .src.\r\n      Object.defineProperty(result, 'src', {\r\n        enumerable: true,\r\n        get: function fn() {\r\n          var src;\r\n          if (!('result' in fn)) {\r\n            src = obj.src;\r\n            // If src is an array, flatten it. Otherwise, make it into an array.\r\n            src = Array.isArray(src) ? flatten(src) : [src];\r\n            // Expand src files, memoizing result.\r\n            fn.result = file.expand(expandOptions, src);\r\n          }\r\n          return fn.result;\r\n        }\r\n      });\r\n    }\r\n\r\n    if ('dest' in result) {\r\n      result.dest = obj.dest;\r\n    }\r\n\r\n    return result;\r\n  }).flatten().value();\r\n\r\n  return files;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vYXJjaGl2ZXItdXRpbHNAMi4xLjAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL2ZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsMEdBQWE7QUFDOUIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDRHQUFnQjtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyxxSEFBbUI7QUFDNUMsWUFBWSxtQkFBTyxDQUFDLHNHQUFjO0FBQ2xDLG9CQUFvQixtQkFBTyxDQUFDLDhIQUFzQjtBQUNsRDtBQUNBLFdBQVcsbUJBQU8sQ0FBQyw2RUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pbGVlMDAvRGVza3RvcC9IUkMtQXBwbGljYXRpb24vbm9kZV9tb2R1bGVzLy5wbnBtL2FyY2hpdmVyLXV0aWxzQDIuMS4wL25vZGVfbW9kdWxlcy9hcmNoaXZlci11dGlscy9maWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBhcmNoaXZlci11dGlsc1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCBDaHJpcyBUYWxraW5ndG9uLCBjb250cmlidXRvcnMuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvbm9kZS1hcmNoaXZlci9ibG9iL21hc3Rlci9MSUNFTlNFLU1JVFxyXG4gKi9cclxudmFyIGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKTtcclxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XHJcblxyXG52YXIgZmxhdHRlbiA9IHJlcXVpcmUoJ2xvZGFzaC5mbGF0dGVuJyk7XHJcbnZhciBkaWZmZXJlbmNlID0gcmVxdWlyZSgnbG9kYXNoLmRpZmZlcmVuY2UnKTtcclxudmFyIHVuaW9uID0gcmVxdWlyZSgnbG9kYXNoLnVuaW9uJyk7XHJcbnZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoLmlzcGxhaW5vYmplY3QnKTtcclxuXHJcbnZhciBnbG9iID0gcmVxdWlyZSgnZ2xvYicpO1xyXG5cclxudmFyIGZpbGUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xyXG5cclxudmFyIHBhdGhTZXBhcmF0b3JSZSA9IC9bXFwvXFxcXF0vZztcclxuXHJcbi8vIFByb2Nlc3Mgc3BlY2lmaWVkIHdpbGRjYXJkIGdsb2IgcGF0dGVybnMgb3IgZmlsZW5hbWVzIGFnYWluc3QgYVxyXG4vLyBjYWxsYmFjaywgZXhjbHVkaW5nIGFuZCB1bmlxdWluZyBmaWxlcyBpbiB0aGUgcmVzdWx0IHNldC5cclxudmFyIHByb2Nlc3NQYXR0ZXJucyA9IGZ1bmN0aW9uKHBhdHRlcm5zLCBmbikge1xyXG4gIC8vIEZpbGVwYXRocyB0byByZXR1cm4uXHJcbiAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gIC8vIEl0ZXJhdGUgb3ZlciBmbGF0dGVuZWQgcGF0dGVybnMgYXJyYXkuXHJcbiAgZmxhdHRlbihwYXR0ZXJucykuZm9yRWFjaChmdW5jdGlvbihwYXR0ZXJuKSB7XHJcbiAgICAvLyBJZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzICEgaXQgc2hvdWxkIGJlIG9taXR0ZWRcclxuICAgIHZhciBleGNsdXNpb24gPSBwYXR0ZXJuLmluZGV4T2YoJyEnKSA9PT0gMDtcclxuICAgIC8vIElmIHRoZSBwYXR0ZXJuIGlzIGFuIGV4Y2x1c2lvbiwgcmVtb3ZlIHRoZSAhXHJcbiAgICBpZiAoZXhjbHVzaW9uKSB7IHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDEpOyB9XHJcbiAgICAvLyBGaW5kIGFsbCBtYXRjaGluZyBmaWxlcyBmb3IgdGhpcyBwYXR0ZXJuLlxyXG4gICAgdmFyIG1hdGNoZXMgPSBmbihwYXR0ZXJuKTtcclxuICAgIGlmIChleGNsdXNpb24pIHtcclxuICAgICAgLy8gSWYgYW4gZXhjbHVzaW9uLCByZW1vdmUgbWF0Y2hpbmcgZmlsZXMuXHJcbiAgICAgIHJlc3VsdCA9IGRpZmZlcmVuY2UocmVzdWx0LCBtYXRjaGVzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIE90aGVyd2lzZSBhZGQgbWF0Y2hpbmcgZmlsZXMuXHJcbiAgICAgIHJlc3VsdCA9IHVuaW9uKHJlc3VsdCwgbWF0Y2hlcyk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8vIFRydWUgaWYgdGhlIGZpbGUgcGF0aCBleGlzdHMuXHJcbmZpbGUuZXhpc3RzID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGZpbGVwYXRoID0gcGF0aC5qb2luLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XHJcbiAgcmV0dXJuIGZzLmV4aXN0c1N5bmMoZmlsZXBhdGgpO1xyXG59O1xyXG5cclxuLy8gUmV0dXJuIGFuIGFycmF5IG9mIGFsbCBmaWxlIHBhdGhzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHdpbGRjYXJkIHBhdHRlcm5zLlxyXG5maWxlLmV4cGFuZCA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcclxuICAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gb3B0aW9ucyBvYmplY3QsIHNhdmUgdGhvc2Ugb3B0aW9ucyB0byBwYXNzXHJcbiAgLy8gaW50byB0aGUgRmlsZS5wcm90b3R5cGUuZ2xvYi5zeW5jIG1ldGhvZC5cclxuICB2YXIgb3B0aW9ucyA9IGlzUGxhaW5PYmplY3QoYXJnc1swXSkgPyBhcmdzLnNoaWZ0KCkgOiB7fTtcclxuICAvLyBVc2UgdGhlIGZpcnN0IGFyZ3VtZW50IGlmIGl0J3MgYW4gQXJyYXksIG90aGVyd2lzZSBjb252ZXJ0IHRoZSBhcmd1bWVudHNcclxuICAvLyBvYmplY3QgdG8gYW4gYXJyYXkgYW5kIHVzZSB0aGF0LlxyXG4gIHZhciBwYXR0ZXJucyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcclxuICAvLyBSZXR1cm4gZW1wdHkgc2V0IGlmIHRoZXJlIGFyZSBubyBwYXR0ZXJucyBvciBmaWxlcGF0aHMuXHJcbiAgaWYgKHBhdHRlcm5zLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gW107IH1cclxuICAvLyBSZXR1cm4gYWxsIG1hdGNoaW5nIGZpbGVwYXRocy5cclxuICB2YXIgbWF0Y2hlcyA9IHByb2Nlc3NQYXR0ZXJucyhwYXR0ZXJucywgZnVuY3Rpb24ocGF0dGVybikge1xyXG4gICAgLy8gRmluZCBhbGwgbWF0Y2hpbmcgZmlsZXMgZm9yIHRoaXMgcGF0dGVybi5cclxuICAgIHJldHVybiBnbG9iLnN5bmMocGF0dGVybiwgb3B0aW9ucyk7XHJcbiAgfSk7XHJcbiAgLy8gRmlsdGVyIHJlc3VsdCBzZXQ/XHJcbiAgaWYgKG9wdGlvbnMuZmlsdGVyKSB7XHJcbiAgICBtYXRjaGVzID0gbWF0Y2hlcy5maWx0ZXIoZnVuY3Rpb24oZmlsZXBhdGgpIHtcclxuICAgICAgZmlsZXBhdGggPSBwYXRoLmpvaW4ob3B0aW9ucy5jd2QgfHwgJycsIGZpbGVwYXRoKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5maWx0ZXIoZmlsZXBhdGgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlsZSBpcyBvZiB0aGUgcmlnaHQgdHlwZSBhbmQgZXhpc3RzLCB0aGlzIHNob3VsZCB3b3JrLlxyXG4gICAgICAgICAgcmV0dXJuIGZzLnN0YXRTeW5jKGZpbGVwYXRoKVtvcHRpb25zLmZpbHRlcl0oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgaXQncyBwcm9iYWJseSBub3QgdGhlIHJpZ2h0IHR5cGUuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIG1hdGNoZXM7XHJcbn07XHJcblxyXG4vLyBCdWlsZCBhIG11bHRpIHRhc2sgXCJmaWxlc1wiIG9iamVjdCBkeW5hbWljYWxseS5cclxuZmlsZS5leHBhbmRNYXBwaW5nID0gZnVuY3Rpb24ocGF0dGVybnMsIGRlc3RCYXNlLCBvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgcmVuYW1lOiBmdW5jdGlvbihkZXN0QmFzZSwgZGVzdFBhdGgpIHtcclxuICAgICAgcmV0dXJuIHBhdGguam9pbihkZXN0QmFzZSB8fCAnJywgZGVzdFBhdGgpO1xyXG4gICAgfVxyXG4gIH0sIG9wdGlvbnMpO1xyXG4gIHZhciBmaWxlcyA9IFtdO1xyXG4gIHZhciBmaWxlQnlEZXN0ID0ge307XHJcbiAgLy8gRmluZCBhbGwgZmlsZXMgbWF0Y2hpbmcgcGF0dGVybiwgdXNpbmcgcGFzc2VkLWluIG9wdGlvbnMuXHJcbiAgZmlsZS5leHBhbmQob3B0aW9ucywgcGF0dGVybnMpLmZvckVhY2goZnVuY3Rpb24oc3JjKSB7XHJcbiAgICB2YXIgZGVzdFBhdGggPSBzcmM7XHJcbiAgICAvLyBGbGF0dGVuP1xyXG4gICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xyXG4gICAgICBkZXN0UGF0aCA9IHBhdGguYmFzZW5hbWUoZGVzdFBhdGgpO1xyXG4gICAgfVxyXG4gICAgLy8gQ2hhbmdlIHRoZSBleHRlbnNpb24/XHJcbiAgICBpZiAob3B0aW9ucy5leHQpIHtcclxuICAgICAgZGVzdFBhdGggPSBkZXN0UGF0aC5yZXBsYWNlKC8oXFwuW15cXC9dKik/JC8sIG9wdGlvbnMuZXh0KTtcclxuICAgIH1cclxuICAgIC8vIEdlbmVyYXRlIGRlc3RpbmF0aW9uIGZpbGVuYW1lLlxyXG4gICAgdmFyIGRlc3QgPSBvcHRpb25zLnJlbmFtZShkZXN0QmFzZSwgZGVzdFBhdGgsIG9wdGlvbnMpO1xyXG4gICAgLy8gUHJlcGVuZCBjd2QgdG8gc3JjIHBhdGggaWYgbmVjZXNzYXJ5LlxyXG4gICAgaWYgKG9wdGlvbnMuY3dkKSB7IHNyYyA9IHBhdGguam9pbihvcHRpb25zLmN3ZCwgc3JjKTsgfVxyXG4gICAgLy8gTm9ybWFsaXplIGZpbGVwYXRocyB0byBiZSB1bml4LXN0eWxlLlxyXG4gICAgZGVzdCA9IGRlc3QucmVwbGFjZShwYXRoU2VwYXJhdG9yUmUsICcvJyk7XHJcbiAgICBzcmMgPSBzcmMucmVwbGFjZShwYXRoU2VwYXJhdG9yUmUsICcvJyk7XHJcbiAgICAvLyBNYXAgY29ycmVjdCBzcmMgcGF0aCB0byBkZXN0IHBhdGguXHJcbiAgICBpZiAoZmlsZUJ5RGVzdFtkZXN0XSkge1xyXG4gICAgICAvLyBJZiBkZXN0IGFscmVhZHkgZXhpc3RzLCBwdXNoIHRoaXMgc3JjIG9udG8gdGhhdCBkZXN0J3Mgc3JjIGFycmF5LlxyXG4gICAgICBmaWxlQnlEZXN0W2Rlc3RdLnNyYy5wdXNoKHNyYyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IHNyYy1kZXN0IGZpbGUgbWFwcGluZyBvYmplY3QuXHJcbiAgICAgIGZpbGVzLnB1c2goe1xyXG4gICAgICAgIHNyYzogW3NyY10sXHJcbiAgICAgICAgZGVzdDogZGVzdCxcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIEFuZCBzdG9yZSBhIHJlZmVyZW5jZSBmb3IgbGF0ZXIgdXNlLlxyXG4gICAgICBmaWxlQnlEZXN0W2Rlc3RdID0gZmlsZXNbZmlsZXMubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGZpbGVzO1xyXG59O1xyXG5cclxuLy8gcmV1c2luZyBiaXRzIG9mIGdydW50J3MgbXVsdGktdGFzayBzb3VyY2Ugbm9ybWFsaXphdGlvblxyXG5maWxlLm5vcm1hbGl6ZUZpbGVzQXJyYXkgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgdmFyIGZpbGVzID0gW107XHJcblxyXG4gIGRhdGEuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBwcm9wO1xyXG4gICAgaWYgKCdzcmMnIGluIG9iaiB8fCAnZGVzdCcgaW4gb2JqKSB7XHJcbiAgICAgIGZpbGVzLnB1c2gob2JqKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgZmlsZXMgPSBfKGZpbGVzKS5jaGFpbigpLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAoISgnc3JjJyBpbiBvYmopIHx8ICFvYmouc3JjKSB7IHJldHVybjsgfVxyXG4gICAgLy8gTm9ybWFsaXplIC5zcmMgcHJvcGVydGllcyB0byBmbGF0dGVuZWQgYXJyYXkuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmouc3JjKSkge1xyXG4gICAgICBvYmouc3JjID0gZmxhdHRlbihvYmouc3JjKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9iai5zcmMgPSBbb2JqLnNyY107XHJcbiAgICB9XHJcbiAgfSkubWFwKGZ1bmN0aW9uKG9iaikge1xyXG4gICAgLy8gQnVpbGQgb3B0aW9ucyBvYmplY3QsIHJlbW92aW5nIHVud2FudGVkIHByb3BlcnRpZXMuXHJcbiAgICB2YXIgZXhwYW5kT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XHJcbiAgICBkZWxldGUgZXhwYW5kT3B0aW9ucy5zcmM7XHJcbiAgICBkZWxldGUgZXhwYW5kT3B0aW9ucy5kZXN0O1xyXG5cclxuICAgIC8vIEV4cGFuZCBmaWxlIG1hcHBpbmdzLlxyXG4gICAgaWYgKG9iai5leHBhbmQpIHtcclxuICAgICAgcmV0dXJuIGZpbGUuZXhwYW5kTWFwcGluZyhvYmouc3JjLCBvYmouZGVzdCwgZXhwYW5kT3B0aW9ucykubWFwKGZ1bmN0aW9uKG1hcE9iaikge1xyXG4gICAgICAgIC8vIENvcHkgb2JqIHByb3BlcnRpZXMgdG8gcmVzdWx0LlxyXG4gICAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xyXG4gICAgICAgIC8vIE1ha2UgYSBjbG9uZSBvZiB0aGUgb3JpZyBvYmogYXZhaWxhYmxlLlxyXG4gICAgICAgIHJlc3VsdC5vcmlnID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcclxuICAgICAgICAvLyBTZXQgLnNyYyBhbmQgLmRlc3QsIHByb2Nlc3NpbmcgYm90aCBhcyB0ZW1wbGF0ZXMuXHJcbiAgICAgICAgcmVzdWx0LnNyYyA9IG1hcE9iai5zcmM7XHJcbiAgICAgICAgcmVzdWx0LmRlc3QgPSBtYXBPYmouZGVzdDtcclxuICAgICAgICAvLyBSZW1vdmUgdW53YW50ZWQgcHJvcGVydGllcy5cclxuICAgICAgICBbJ2V4cGFuZCcsICdjd2QnLCAnZmxhdHRlbicsICdyZW5hbWUnLCAnZXh0J10uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XHJcbiAgICAgICAgICBkZWxldGUgcmVzdWx0W3Byb3BdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvcHkgb2JqIHByb3BlcnRpZXMgdG8gcmVzdWx0LCBhZGRpbmcgYW4gLm9yaWcgcHJvcGVydHkuXHJcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcclxuICAgIC8vIE1ha2UgYSBjbG9uZSBvZiB0aGUgb3JpZyBvYmogYXZhaWxhYmxlLlxyXG4gICAgcmVzdWx0Lm9yaWcgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xyXG5cclxuICAgIGlmICgnc3JjJyBpbiByZXN1bHQpIHtcclxuICAgICAgLy8gRXhwb3NlIGFuIGV4cGFuZC1vbi1kZW1hbmQgZ2V0dGVyIG1ldGhvZCBhcyAuc3JjLlxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCAnc3JjJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBmbigpIHtcclxuICAgICAgICAgIHZhciBzcmM7XHJcbiAgICAgICAgICBpZiAoISgncmVzdWx0JyBpbiBmbikpIHtcclxuICAgICAgICAgICAgc3JjID0gb2JqLnNyYztcclxuICAgICAgICAgICAgLy8gSWYgc3JjIGlzIGFuIGFycmF5LCBmbGF0dGVuIGl0LiBPdGhlcndpc2UsIG1ha2UgaXQgaW50byBhbiBhcnJheS5cclxuICAgICAgICAgICAgc3JjID0gQXJyYXkuaXNBcnJheShzcmMpID8gZmxhdHRlbihzcmMpIDogW3NyY107XHJcbiAgICAgICAgICAgIC8vIEV4cGFuZCBzcmMgZmlsZXMsIG1lbW9pemluZyByZXN1bHQuXHJcbiAgICAgICAgICAgIGZuLnJlc3VsdCA9IGZpbGUuZXhwYW5kKGV4cGFuZE9wdGlvbnMsIHNyYyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZm4ucmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCdkZXN0JyBpbiByZXN1bHQpIHtcclxuICAgICAgcmVzdWx0LmRlc3QgPSBvYmouZGVzdDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0pLmZsYXR0ZW4oKS52YWx1ZSgpO1xyXG5cclxuICByZXR1cm4gZmlsZXM7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/index.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\r\n * archiver-utils\r\n *\r\n * Copyright (c) 2015 Chris Talkington.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/archiver-utils/blob/master/LICENSE\r\n */\r\nvar fs = __webpack_require__(/*! graceful-fs */ \"(rsc)/./node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\nvar nutil = __webpack_require__(/*! util */ \"util\");\r\nvar lazystream = __webpack_require__(/*! lazystream */ \"(rsc)/./node_modules/.pnpm/lazystream@1.0.1/node_modules/lazystream/lib/lazystream.js\");\r\nvar normalizePath = __webpack_require__(/*! normalize-path */ \"(rsc)/./node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js\");\r\nvar defaults = __webpack_require__(/*! lodash.defaults */ \"(rsc)/./node_modules/.pnpm/lodash.defaults@4.2.0/node_modules/lodash.defaults/index.js\");\r\n\r\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\r\nvar PassThrough = (__webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/readable.js\").PassThrough);\r\n\r\nvar utils = module.exports = {};\r\nutils.file = __webpack_require__(/*! ./file.js */ \"(rsc)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/file.js\");\r\n\r\nfunction assertPath(path) {\r\n  if (typeof path !== 'string') {\r\n    throw new TypeError('Path must be a string. Received ' + nutils.inspect(path));\r\n  }\r\n}\r\n\r\nutils.collectStream = function(source, callback) {\r\n  var collection = [];\r\n  var size = 0;\r\n\r\n  source.on('error', callback);\r\n\r\n  source.on('data', function(chunk) {\r\n    collection.push(chunk);\r\n    size += chunk.length;\r\n  });\r\n\r\n  source.on('end', function() {\r\n    var buf = new Buffer(size);\r\n    var offset = 0;\r\n\r\n    collection.forEach(function(data) {\r\n      data.copy(buf, offset);\r\n      offset += data.length;\r\n    });\r\n\r\n    callback(null, buf);\r\n  });\r\n};\r\n\r\nutils.dateify = function(dateish) {\r\n  dateish = dateish || new Date();\r\n\r\n  if (dateish instanceof Date) {\r\n    dateish = dateish;\r\n  } else if (typeof dateish === 'string') {\r\n    dateish = new Date(dateish);\r\n  } else {\r\n    dateish = new Date();\r\n  }\r\n\r\n  return dateish;\r\n};\r\n\r\n// this is slightly different from lodash version\r\nutils.defaults = function(object, source, guard) {\r\n  var args = arguments;\r\n  args[0] = args[0] || {};\r\n\r\n  return defaults(...args);\r\n};\r\n\r\nutils.isStream = function(source) {\r\n  return source instanceof Stream;\r\n};\r\n\r\nutils.lazyReadStream = function(filepath) {\r\n  return new lazystream.Readable(function() {\r\n    return fs.createReadStream(filepath);\r\n  });\r\n};\r\n\r\nutils.normalizeInputSource = function(source) {\r\n  if (source === null) {\r\n    return new Buffer(0);\r\n  } else if (typeof source === 'string') {\r\n    return new Buffer(source);\r\n  } else if (utils.isStream(source) && !source._readableState) {\r\n    var normalized = new PassThrough();\r\n    source.pipe(normalized);\r\n\r\n    return normalized;\r\n  }\r\n\r\n  return source;\r\n};\r\n\r\nutils.sanitizePath = function(filepath) {\r\n  return normalizePath(filepath, false).replace(/^\\w+:/, '').replace(/^(\\.\\.\\/|\\/)+/, '');\r\n};\r\n\r\nutils.trailingSlashIt = function(str) {\r\n  return str.slice(-1) !== '/' ? str + '/' : str;\r\n};\r\n\r\nutils.unixifyPath = function(filepath) {\r\n  return normalizePath(filepath, false).replace(/^\\w+:/, '');\r\n};\r\n\r\nutils.walkdir = function(dirpath, base, callback) {\r\n  var results = [];\r\n\r\n  if (typeof base === 'function') {\r\n    callback = base;\r\n    base = dirpath;\r\n  }\r\n\r\n  fs.readdir(dirpath, function(err, list) {\r\n    var i = 0;\r\n    var file;\r\n    var filepath;\r\n\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n\r\n    (function next() {\r\n      file = list[i++];\r\n\r\n      if (!file) {\r\n        return callback(null, results);\r\n      }\r\n\r\n      filepath = path.join(dirpath, file);\r\n\r\n      fs.stat(filepath, function(err, stats) {\r\n        results.push({\r\n          path: filepath,\r\n          relative: path.relative(base, filepath).replace(/\\\\/g, '/'),\r\n          stats: stats\r\n        });\r\n\r\n        if (stats && stats.isDirectory()) {\r\n          utils.walkdir(filepath, base, function(err, res) {\r\n            res.forEach(function(dirEntry) {\r\n              results.push(dirEntry);\r\n            });\r\n            next();\r\n          });\r\n        } else {\r\n          next();\r\n        }\r\n      });\r\n    })();\r\n  });\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vYXJjaGl2ZXItdXRpbHNAMi4xLjAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLDBHQUFhO0FBQzlCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsa0JBQU07QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMseUdBQVk7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsNEdBQWdCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQywrR0FBaUI7QUFDeEM7QUFDQSxhQUFhLG9EQUF3QjtBQUNyQyxrQkFBa0IscUpBQXNDO0FBQ3hEO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0dBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiL1VzZXJzL2lsZWUwMC9EZXNrdG9wL0hSQy1BcHBsaWNhdGlvbi9ub2RlX21vZHVsZXMvLnBucG0vYXJjaGl2ZXItdXRpbHNAMi4xLjAvbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBhcmNoaXZlci11dGlsc1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2hyaXMgVGFsa2luZ3Rvbi5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJjaGl2ZXJqcy9hcmNoaXZlci11dGlscy9ibG9iL21hc3Rlci9MSUNFTlNFXHJcbiAqL1xyXG52YXIgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpO1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxudmFyIG51dGlsID0gcmVxdWlyZSgndXRpbCcpO1xyXG52YXIgbGF6eXN0cmVhbSA9IHJlcXVpcmUoJ2xhenlzdHJlYW0nKTtcclxudmFyIG5vcm1hbGl6ZVBhdGggPSByZXF1aXJlKCdub3JtYWxpemUtcGF0aCcpO1xyXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCdsb2Rhc2guZGVmYXVsdHMnKTtcclxuXHJcbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW07XHJcbnZhciBQYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlBhc3NUaHJvdWdoO1xyXG5cclxudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcclxudXRpbHMuZmlsZSA9IHJlcXVpcmUoJy4vZmlsZS5qcycpO1xyXG5cclxuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoKSB7XHJcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAnICsgbnV0aWxzLmluc3BlY3QocGF0aCkpO1xyXG4gIH1cclxufVxyXG5cclxudXRpbHMuY29sbGVjdFN0cmVhbSA9IGZ1bmN0aW9uKHNvdXJjZSwgY2FsbGJhY2spIHtcclxuICB2YXIgY29sbGVjdGlvbiA9IFtdO1xyXG4gIHZhciBzaXplID0gMDtcclxuXHJcbiAgc291cmNlLm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcclxuXHJcbiAgc291cmNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcclxuICAgIGNvbGxlY3Rpb24ucHVzaChjaHVuayk7XHJcbiAgICBzaXplICs9IGNodW5rLmxlbmd0aDtcclxuICB9KTtcclxuXHJcbiAgc291cmNlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcclxuICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xyXG4gICAgdmFyIG9mZnNldCA9IDA7XHJcblxyXG4gICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgZGF0YS5jb3B5KGJ1Ziwgb2Zmc2V0KTtcclxuICAgICAgb2Zmc2V0ICs9IGRhdGEubGVuZ3RoO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY2FsbGJhY2sobnVsbCwgYnVmKTtcclxuICB9KTtcclxufTtcclxuXHJcbnV0aWxzLmRhdGVpZnkgPSBmdW5jdGlvbihkYXRlaXNoKSB7XHJcbiAgZGF0ZWlzaCA9IGRhdGVpc2ggfHwgbmV3IERhdGUoKTtcclxuXHJcbiAgaWYgKGRhdGVpc2ggaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICBkYXRlaXNoID0gZGF0ZWlzaDtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRlaXNoID09PSAnc3RyaW5nJykge1xyXG4gICAgZGF0ZWlzaCA9IG5ldyBEYXRlKGRhdGVpc2gpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkYXRlaXNoID0gbmV3IERhdGUoKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBkYXRlaXNoO1xyXG59O1xyXG5cclxuLy8gdGhpcyBpcyBzbGlnaHRseSBkaWZmZXJlbnQgZnJvbSBsb2Rhc2ggdmVyc2lvblxyXG51dGlscy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBndWFyZCkge1xyXG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gIGFyZ3NbMF0gPSBhcmdzWzBdIHx8IHt9O1xyXG5cclxuICByZXR1cm4gZGVmYXVsdHMoLi4uYXJncyk7XHJcbn07XHJcblxyXG51dGlscy5pc1N0cmVhbSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG4gIHJldHVybiBzb3VyY2UgaW5zdGFuY2VvZiBTdHJlYW07XHJcbn07XHJcblxyXG51dGlscy5sYXp5UmVhZFN0cmVhbSA9IGZ1bmN0aW9uKGZpbGVwYXRoKSB7XHJcbiAgcmV0dXJuIG5ldyBsYXp5c3RyZWFtLlJlYWRhYmxlKGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZXBhdGgpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxudXRpbHMubm9ybWFsaXplSW5wdXRTb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcclxuICBpZiAoc291cmNlID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzb3VyY2UpO1xyXG4gIH0gZWxzZSBpZiAodXRpbHMuaXNTdHJlYW0oc291cmNlKSAmJiAhc291cmNlLl9yZWFkYWJsZVN0YXRlKSB7XHJcbiAgICB2YXIgbm9ybWFsaXplZCA9IG5ldyBQYXNzVGhyb3VnaCgpO1xyXG4gICAgc291cmNlLnBpcGUobm9ybWFsaXplZCk7XHJcblxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc291cmNlO1xyXG59O1xyXG5cclxudXRpbHMuc2FuaXRpemVQYXRoID0gZnVuY3Rpb24oZmlsZXBhdGgpIHtcclxuICByZXR1cm4gbm9ybWFsaXplUGF0aChmaWxlcGF0aCwgZmFsc2UpLnJlcGxhY2UoL15cXHcrOi8sICcnKS5yZXBsYWNlKC9eKFxcLlxcLlxcL3xcXC8pKy8sICcnKTtcclxufTtcclxuXHJcbnV0aWxzLnRyYWlsaW5nU2xhc2hJdCA9IGZ1bmN0aW9uKHN0cikge1xyXG4gIHJldHVybiBzdHIuc2xpY2UoLTEpICE9PSAnLycgPyBzdHIgKyAnLycgOiBzdHI7XHJcbn07XHJcblxyXG51dGlscy51bml4aWZ5UGF0aCA9IGZ1bmN0aW9uKGZpbGVwYXRoKSB7XHJcbiAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgoZmlsZXBhdGgsIGZhbHNlKS5yZXBsYWNlKC9eXFx3KzovLCAnJyk7XHJcbn07XHJcblxyXG51dGlscy53YWxrZGlyID0gZnVuY3Rpb24oZGlycGF0aCwgYmFzZSwgY2FsbGJhY2spIHtcclxuICB2YXIgcmVzdWx0cyA9IFtdO1xyXG5cclxuICBpZiAodHlwZW9mIGJhc2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGNhbGxiYWNrID0gYmFzZTtcclxuICAgIGJhc2UgPSBkaXJwYXRoO1xyXG4gIH1cclxuXHJcbiAgZnMucmVhZGRpcihkaXJwYXRoLCBmdW5jdGlvbihlcnIsIGxpc3QpIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciBmaWxlO1xyXG4gICAgdmFyIGZpbGVwYXRoO1xyXG5cclxuICAgIGlmIChlcnIpIHtcclxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICB9XHJcblxyXG4gICAgKGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICAgIGZpbGUgPSBsaXN0W2krK107XHJcblxyXG4gICAgICBpZiAoIWZpbGUpIHtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZpbGVwYXRoID0gcGF0aC5qb2luKGRpcnBhdGgsIGZpbGUpO1xyXG5cclxuICAgICAgZnMuc3RhdChmaWxlcGF0aCwgZnVuY3Rpb24oZXJyLCBzdGF0cykge1xyXG4gICAgICAgIHJlc3VsdHMucHVzaCh7XHJcbiAgICAgICAgICBwYXRoOiBmaWxlcGF0aCxcclxuICAgICAgICAgIHJlbGF0aXZlOiBwYXRoLnJlbGF0aXZlKGJhc2UsIGZpbGVwYXRoKS5yZXBsYWNlKC9cXFxcL2csICcvJyksXHJcbiAgICAgICAgICBzdGF0czogc3RhdHNcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcclxuICAgICAgICAgIHV0aWxzLndhbGtkaXIoZmlsZXBhdGgsIGJhc2UsIGZ1bmN0aW9uKGVyciwgcmVzKSB7XHJcbiAgICAgICAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uKGRpckVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGRpckVudHJ5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG5leHQoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pKCk7XHJcbiAgfSk7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/archiver-utils@2.1.0/node_modules/archiver-utils/index.js\n");

/***/ })

};
;